/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KL27P64M48SF6RM, Rev.3, Aug 2014
**     Version:             rev. 1.4, 2014-09-01
**     Build:               b140901
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-03-27)
**         Initial version.
**     - rev. 1.1 (2014-05-26)
**         I2S registers TCR2/RCR2 and others were changed.
**         FLEXIO register FLEXIO_VERID has now bitfields: FEATURE, MINOR, MAJOR.
**         Names of the bitfields of the FLEXIO_SHIFTBUF have been changed to the appropriate register name e.g.: FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS.
**         Peripheral_BASES macros has been changed to Peripheral_BASE_PTRS, e.g.: ADC_BASES to ADC_BASE_PTRS.
**         Clock configuration for high range external oscillator has been added.
**         RFSYS module access has been added.
**     - rev. 1.2 (2014-07-10)
**         GPIO - Renamed modules PTA,PTB,PTC,PTD,PTE to GPIOA,GPIOB,GPIOC,GPIOD,GPIOE.
**         UART0 - UART0 module renamed to UART2.
**         I2S - removed MDR register.
**     - rev. 1.3 (2014-08-21)
**         UART2 - Removed ED register.
**         UART2 - Removed MODEM register.
**         UART2 - Removed IR register.
**         UART2 - Removed PFIFO register.
**         UART2 - Removed CFIFO register.
**         UART2 - Removed SFIFO register.
**         UART2 - Removed TWFIFO register.
**         UART2 - Removed TCFIFO register.
**         UART2 - Removed RWFIFO register.
**         UART2 - Removed RCFIFO register.
**         USB - Removed bitfield REG_EN in CLK_RECOVER_IRC_EN register.
**         SIM - Changed bitfield value MCGIRCLK to LIRC_CLK of bitfield CLKOUTSEL in SOPT2 register.
**         SIM - Removed bitfield DIEID in SDID register.
**     - rev. 1.4 (2014-09-01)
**         USB - USB0_CTL0 was renamed to USB0_OTGCTL register.
**         USB - USB0_CTL1 was renamed to USB0_CTL register.
**     - rev. 1.5 (2014-09-05)
**         USB - USBEN bitfield of the USB0_CTL renamed to USBENSOFEN.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_USB_REGISTERS_H__
#define __HW_USB_REGISTERS_H__

#include "MKL27Z4.h"
#include "fsl_bitaccess.h"

/*
 * MKL27Z4 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - HW_USB_PERID - Peripheral ID register
 * - HW_USB_IDCOMP - Peripheral ID Complement register
 * - HW_USB_REV - Peripheral Revision register
 * - HW_USB_ADDINFO - Peripheral Additional Info register
 * - HW_USB_OTGCTL - OTG Control register
 * - HW_USB_ISTAT - Interrupt Status register
 * - HW_USB_INTEN - Interrupt Enable register
 * - HW_USB_ERRSTAT - Error Interrupt Status register
 * - HW_USB_ERREN - Error Interrupt Enable register
 * - HW_USB_STAT - Status register
 * - HW_USB_CTL - Control register
 * - HW_USB_ADDR - Address register
 * - HW_USB_BDTPAGE1 - BDT Page register 1
 * - HW_USB_FRMNUML - Frame Number register Low
 * - HW_USB_FRMNUMH - Frame Number register High
 * - HW_USB_BDTPAGE2 - BDT Page Register 2
 * - HW_USB_BDTPAGE3 - BDT Page Register 3
 * - HW_USB_ENDPTn - Endpoint Control register
 * - HW_USB_USBCTRL - USB Control register
 * - HW_USB_OBSERVE - USB OTG Observe register
 * - HW_USB_CONTROL - USB OTG Control register
 * - HW_USB_USBTRC0 - USB Transceiver Control register 0
 * - HW_USB_USBFRMADJUST - Frame Adjust Register
 * - HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 * - HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 *
 * - hw_usb_t - Struct containing all module registers.
 */

#define HW_USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define HW_USB0 (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * HW_USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief HW_USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
typedef union _hw_usb_perid
{
    uint8_t U;
    struct _hw_usb_perid_bitfields
    {
        uint8_t ID : 6;                /*!< [5:0] Peripheral Identification */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_perid_t;

/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define HW_USB_PERID_ADDR(x)     ((x) + 0x0U)

#define HW_USB_PERID(x)          (*(__I hw_usb_perid_t *) HW_USB_PERID_ADDR(x))
#define HW_USB_PERID_RD(x)       (HW_USB_PERID(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
#define BP_USB_PERID_ID      (0U)          /*!< Bit position for USB_PERID_ID. */
#define BM_USB_PERID_ID      (0x3FU)       /*!< Bit mask for USB_PERID_ID. */
#define BS_USB_PERID_ID      (6U)          /*!< Bit field size in bits for USB_PERID_ID. */

/*! @brief Read current value of the USB_PERID_ID field. */
#define BR_USB_PERID_ID(x)   (BME_UBFX8(HW_USB_PERID_ADDR(x), BP_USB_PERID_ID, BS_USB_PERID_ID))
/*@}*/

/*******************************************************************************
 * HW_USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief HW_USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
typedef union _hw_usb_idcomp
{
    uint8_t U;
    struct _hw_usb_idcomp_bitfields
    {
        uint8_t NID : 6;               /*!< [5:0]  */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_idcomp_t;

/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define HW_USB_IDCOMP_ADDR(x)    ((x) + 0x4U)

#define HW_USB_IDCOMP(x)         (*(__I hw_usb_idcomp_t *) HW_USB_IDCOMP_ADDR(x))
#define HW_USB_IDCOMP_RD(x)      (HW_USB_IDCOMP(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID]. bits.
 */
/*@{*/
#define BP_USB_IDCOMP_NID    (0U)          /*!< Bit position for USB_IDCOMP_NID. */
#define BM_USB_IDCOMP_NID    (0x3FU)       /*!< Bit mask for USB_IDCOMP_NID. */
#define BS_USB_IDCOMP_NID    (6U)          /*!< Bit field size in bits for USB_IDCOMP_NID. */

/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define BR_USB_IDCOMP_NID(x) (BME_UBFX8(HW_USB_IDCOMP_ADDR(x), BP_USB_IDCOMP_NID, BS_USB_IDCOMP_NID))
/*@}*/

/*******************************************************************************
 * HW_USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief HW_USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
typedef union _hw_usb_rev
{
    uint8_t U;
    struct _hw_usb_rev_bitfields
    {
        uint8_t REV : 8;               /*!< [7:0] Revision */
    } B;
} hw_usb_rev_t;

/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define HW_USB_REV_ADDR(x)       ((x) + 0x8U)

#define HW_USB_REV(x)            (*(__I hw_usb_rev_t *) HW_USB_REV_ADDR(x))
#define HW_USB_REV_RD(x)         (HW_USB_REV(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_REV bitfields
 */

/*!
 * @name Register USB_REV, field REV[7:0] (RO)
 *
 * Indicates the revision number of the USB Core.
 */
/*@{*/
#define BP_USB_REV_REV       (0U)          /*!< Bit position for USB_REV_REV. */
#define BM_USB_REV_REV       (0xFFU)       /*!< Bit mask for USB_REV_REV. */
#define BS_USB_REV_REV       (8U)          /*!< Bit field size in bits for USB_REV_REV. */

/*! @brief Read current value of the USB_REV_REV field. */
#define BR_USB_REV_REV(x)    (HW_USB_REV(x).U)
/*@}*/

/*******************************************************************************
 * HW_USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the Host Enable bit.
 */
typedef union _hw_usb_addinfo
{
    uint8_t U;
    struct _hw_usb_addinfo_bitfields
    {
        uint8_t IEHOST : 1;            /*!< [0]  */
        uint8_t RESERVED0 : 7;         /*!< [7:1]  */
    } B;
} hw_usb_addinfo_t;

/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define HW_USB_ADDINFO_ADDR(x)   ((x) + 0xCU)

#define HW_USB_ADDINFO(x)        (*(__I hw_usb_addinfo_t *) HW_USB_ADDINFO_ADDR(x))
#define HW_USB_ADDINFO_RD(x)     (HW_USB_ADDINFO(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
#define BP_USB_ADDINFO_IEHOST (0U)         /*!< Bit position for USB_ADDINFO_IEHOST. */
#define BM_USB_ADDINFO_IEHOST (0x01U)      /*!< Bit mask for USB_ADDINFO_IEHOST. */
#define BS_USB_ADDINFO_IEHOST (1U)         /*!< Bit field size in bits for USB_ADDINFO_IEHOST. */

/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define BR_USB_ADDINFO_IEHOST(x) (BME_UBFX8(HW_USB_ADDINFO_ADDR(x), BP_USB_ADDINFO_IEHOST, BS_USB_ADDINFO_IEHOST))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
typedef union _hw_usb_otgctl
{
    uint8_t U;
    struct _hw_usb_otgctl_bitfields
    {
        uint8_t RESERVED0 : 7;         /*!< [6:0]  */
        uint8_t DPHIGH : 1;            /*!< [7] D+ Data Line pullup resistor enable */
    } B;
} hw_usb_otgctl_t;

/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define HW_USB_OTGCTL_ADDR(x)    ((uint32_t)(x) + 0x1CU)

#define HW_USB_OTGCTL(x)         (*(__IO hw_usb_otgctl_t *) HW_USB_OTGCTL_ADDR(x))
#define HW_USB_OTGCTL_RD(x)      (HW_USB_OTGCTL(x).U)
#define HW_USB_OTGCTL_WR(x, v)   (HW_USB_OTGCTL(x).U = (v))
#define HW_USB_OTGCTL_SET(x, v)  (BME_OR8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(v)))
#define HW_USB_OTGCTL_CLR(x, v)  (BME_AND8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_OTGCTL_TOG(x, v)  (BME_XOR8(HW_USB_OTGCTL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
#define BP_USB_OTGCTL_DPHIGH (7U)          /*!< Bit position for USB_OTGCTL_DPHIGH. */
#define BM_USB_OTGCTL_DPHIGH (0x80U)       /*!< Bit mask for USB_OTGCTL_DPHIGH. */
#define BS_USB_OTGCTL_DPHIGH (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPHIGH. */

/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define BR_USB_OTGCTL_DPHIGH(x) (BME_UBFX8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH, BS_USB_OTGCTL_DPHIGH))

/*! @brief Format value for bitfield USB_OTGCTL_DPHIGH. */
#define BF_USB_OTGCTL_DPHIGH(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH) & BM_USB_OTGCTL_DPHIGH)

/*! @brief Set the DPHIGH field to a new value. */
#define BW_USB_OTGCTL_DPHIGH(x, v) (BME_BFI8(HW_USB_OTGCTL_ADDR(x), ((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH), BP_USB_OTGCTL_DPHIGH, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ISTAT - Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * After an interrupt bit has been set it may only be cleared by writing a one to
 * the respective interrupt bit. This register contains the value of 0x00 after a
 * reset.
 */
typedef union _hw_usb_istat
{
    uint8_t U;
    struct _hw_usb_istat_bitfields
    {
        uint8_t USBRST : 1;            /*!< [0]  */
        uint8_t ERROR : 1;             /*!< [1]  */
        uint8_t SOFTOK : 1;            /*!< [2]  */
        uint8_t TOKDNE : 1;            /*!< [3]  */
        uint8_t SLEEP : 1;             /*!< [4]  */
        uint8_t RESUME : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6] Reserved */
        uint8_t STALL : 1;             /*!< [7] Stall Interrupt */
    } B;
} hw_usb_istat_t;

/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define HW_USB_ISTAT_ADDR(x)     ((x) + 0x80U)

#define HW_USB_ISTAT(x)          (*(__IO hw_usb_istat_t *) HW_USB_ISTAT_ADDR(x))
#define HW_USB_ISTAT_RD(x)       (HW_USB_ISTAT(x).U)
#define HW_USB_ISTAT_WR(x, v)    (HW_USB_ISTAT(x).U = (v))
#define HW_USB_ISTAT_SET(x, v)   (BME_OR8(HW_USB_ISTAT_ADDR(x), (uint8_t)(v)))
#define HW_USB_ISTAT_CLR(x, v)   (BME_AND8(HW_USB_ISTAT_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ISTAT_TOG(x, v)   (BME_XOR8(HW_USB_ISTAT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
#define BP_USB_ISTAT_USBRST  (0U)          /*!< Bit position for USB_ISTAT_USBRST. */
#define BM_USB_ISTAT_USBRST  (0x01U)       /*!< Bit mask for USB_ISTAT_USBRST. */
#define BS_USB_ISTAT_USBRST  (1U)          /*!< Bit field size in bits for USB_ISTAT_USBRST. */

/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define BR_USB_ISTAT_USBRST(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST, BS_USB_ISTAT_USBRST))

/*! @brief Format value for bitfield USB_ISTAT_USBRST. */
#define BF_USB_ISTAT_USBRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_USBRST) & BM_USB_ISTAT_USBRST)

/*! @brief Set the USBRST field to a new value. */
#define BW_USB_ISTAT_USBRST(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_USBRST), BP_USB_ISTAT_USBRST, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
#define BP_USB_ISTAT_ERROR   (1U)          /*!< Bit position for USB_ISTAT_ERROR. */
#define BM_USB_ISTAT_ERROR   (0x02U)       /*!< Bit mask for USB_ISTAT_ERROR. */
#define BS_USB_ISTAT_ERROR   (1U)          /*!< Bit field size in bits for USB_ISTAT_ERROR. */

/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define BR_USB_ISTAT_ERROR(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR, BS_USB_ISTAT_ERROR))

/*! @brief Format value for bitfield USB_ISTAT_ERROR. */
#define BF_USB_ISTAT_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ERROR) & BM_USB_ISTAT_ERROR)

/*! @brief Set the ERROR field to a new value. */
#define BW_USB_ISTAT_ERROR(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_ERROR), BP_USB_ISTAT_ERROR, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token.
 */
/*@{*/
#define BP_USB_ISTAT_SOFTOK  (2U)          /*!< Bit position for USB_ISTAT_SOFTOK. */
#define BM_USB_ISTAT_SOFTOK  (0x04U)       /*!< Bit mask for USB_ISTAT_SOFTOK. */
#define BS_USB_ISTAT_SOFTOK  (1U)          /*!< Bit field size in bits for USB_ISTAT_SOFTOK. */

/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define BR_USB_ISTAT_SOFTOK(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK, BS_USB_ISTAT_SOFTOK))

/*! @brief Format value for bitfield USB_ISTAT_SOFTOK. */
#define BF_USB_ISTAT_SOFTOK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SOFTOK) & BM_USB_ISTAT_SOFTOK)

/*! @brief Set the SOFTOK field to a new value. */
#define BW_USB_ISTAT_SOFTOK(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_SOFTOK), BP_USB_ISTAT_SOFTOK, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
#define BP_USB_ISTAT_TOKDNE  (3U)          /*!< Bit position for USB_ISTAT_TOKDNE. */
#define BM_USB_ISTAT_TOKDNE  (0x08U)       /*!< Bit mask for USB_ISTAT_TOKDNE. */
#define BS_USB_ISTAT_TOKDNE  (1U)          /*!< Bit field size in bits for USB_ISTAT_TOKDNE. */

/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define BR_USB_ISTAT_TOKDNE(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE, BS_USB_ISTAT_TOKDNE))

/*! @brief Format value for bitfield USB_ISTAT_TOKDNE. */
#define BF_USB_ISTAT_TOKDNE(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_TOKDNE) & BM_USB_ISTAT_TOKDNE)

/*! @brief Set the TOKDNE field to a new value. */
#define BW_USB_ISTAT_TOKDNE(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_TOKDNE), BP_USB_ISTAT_TOKDNE, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
#define BP_USB_ISTAT_SLEEP   (4U)          /*!< Bit position for USB_ISTAT_SLEEP. */
#define BM_USB_ISTAT_SLEEP   (0x10U)       /*!< Bit mask for USB_ISTAT_SLEEP. */
#define BS_USB_ISTAT_SLEEP   (1U)          /*!< Bit field size in bits for USB_ISTAT_SLEEP. */

/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define BR_USB_ISTAT_SLEEP(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP, BS_USB_ISTAT_SLEEP))

/*! @brief Format value for bitfield USB_ISTAT_SLEEP. */
#define BF_USB_ISTAT_SLEEP(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SLEEP) & BM_USB_ISTAT_SLEEP)

/*! @brief Set the SLEEP field to a new value. */
#define BW_USB_ISTAT_SLEEP(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_SLEEP), BP_USB_ISTAT_SLEEP, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
#define BP_USB_ISTAT_RESUME  (5U)          /*!< Bit position for USB_ISTAT_RESUME. */
#define BM_USB_ISTAT_RESUME  (0x20U)       /*!< Bit mask for USB_ISTAT_RESUME. */
#define BS_USB_ISTAT_RESUME  (1U)          /*!< Bit field size in bits for USB_ISTAT_RESUME. */

/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define BR_USB_ISTAT_RESUME(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME, BS_USB_ISTAT_RESUME))

/*! @brief Format value for bitfield USB_ISTAT_RESUME. */
#define BF_USB_ISTAT_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_RESUME) & BM_USB_ISTAT_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_ISTAT_RESUME(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_RESUME), BP_USB_ISTAT_RESUME, 1))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the SIE.
 */
/*@{*/
#define BP_USB_ISTAT_STALL   (7U)          /*!< Bit position for USB_ISTAT_STALL. */
#define BM_USB_ISTAT_STALL   (0x80U)       /*!< Bit mask for USB_ISTAT_STALL. */
#define BS_USB_ISTAT_STALL   (1U)          /*!< Bit field size in bits for USB_ISTAT_STALL. */

/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define BR_USB_ISTAT_STALL(x) (BME_UBFX8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL, BS_USB_ISTAT_STALL))

/*! @brief Format value for bitfield USB_ISTAT_STALL. */
#define BF_USB_ISTAT_STALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_STALL) & BM_USB_ISTAT_STALL)

/*! @brief Set the STALL field to a new value. */
#define BW_USB_ISTAT_STALL(x, v) (BME_BFI8(HW_USB_ISTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ISTAT_STALL), BP_USB_ISTAT_STALL, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_inten
{
    uint8_t U;
    struct _hw_usb_inten_bitfields
    {
        uint8_t USBRSTEN : 1;          /*!< [0] USBRST Interrupt Enable */
        uint8_t ERROREN : 1;           /*!< [1] ERROR Interrupt Enable */
        uint8_t SOFTOKEN : 1;          /*!< [2] SOFTOK Interrupt Enable */
        uint8_t TOKDNEEN : 1;          /*!< [3] TOKDNE Interrupt Enable */
        uint8_t SLEEPEN : 1;           /*!< [4] SLEEP Interrupt Enable */
        uint8_t RESUMEEN : 1;          /*!< [5] RESUME Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t STALLEN : 1;           /*!< [7] STALL Interrupt Enable */
    } B;
} hw_usb_inten_t;

/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define HW_USB_INTEN_ADDR(x)     ((x) + 0x84U)

#define HW_USB_INTEN(x)          (*(__IO hw_usb_inten_t *) HW_USB_INTEN_ADDR(x))
#define HW_USB_INTEN_RD(x)       (HW_USB_INTEN(x).U)
#define HW_USB_INTEN_WR(x, v)    (HW_USB_INTEN(x).U = (v))
#define HW_USB_INTEN_SET(x, v)   (BME_OR8(HW_USB_INTEN_ADDR(x), (uint8_t)(v)))
#define HW_USB_INTEN_CLR(x, v)   (BME_AND8(HW_USB_INTEN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_INTEN_TOG(x, v)   (BME_XOR8(HW_USB_INTEN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the USBRST interrupt.
 * - 1 - Enables the USBRST interrupt.
 */
/*@{*/
#define BP_USB_INTEN_USBRSTEN (0U)         /*!< Bit position for USB_INTEN_USBRSTEN. */
#define BM_USB_INTEN_USBRSTEN (0x01U)      /*!< Bit mask for USB_INTEN_USBRSTEN. */
#define BS_USB_INTEN_USBRSTEN (1U)         /*!< Bit field size in bits for USB_INTEN_USBRSTEN. */

/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define BR_USB_INTEN_USBRSTEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN, BS_USB_INTEN_USBRSTEN))

/*! @brief Format value for bitfield USB_INTEN_USBRSTEN. */
#define BF_USB_INTEN_USBRSTEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_USBRSTEN) & BM_USB_INTEN_USBRSTEN)

/*! @brief Set the USBRSTEN field to a new value. */
#define BW_USB_INTEN_USBRSTEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_USBRSTEN), BP_USB_INTEN_USBRSTEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - Disables the ERROR interrupt.
 * - 1 - Enables the ERROR interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ERROREN (1U)          /*!< Bit position for USB_INTEN_ERROREN. */
#define BM_USB_INTEN_ERROREN (0x02U)       /*!< Bit mask for USB_INTEN_ERROREN. */
#define BS_USB_INTEN_ERROREN (1U)          /*!< Bit field size in bits for USB_INTEN_ERROREN. */

/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define BR_USB_INTEN_ERROREN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN, BS_USB_INTEN_ERROREN))

/*! @brief Format value for bitfield USB_INTEN_ERROREN. */
#define BF_USB_INTEN_ERROREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ERROREN) & BM_USB_INTEN_ERROREN)

/*! @brief Set the ERROREN field to a new value. */
#define BW_USB_INTEN_ERROREN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_ERROREN), BP_USB_INTEN_ERROREN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - Disbles the SOFTOK interrupt.
 * - 1 - Enables the SOFTOK interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SOFTOKEN (2U)         /*!< Bit position for USB_INTEN_SOFTOKEN. */
#define BM_USB_INTEN_SOFTOKEN (0x04U)      /*!< Bit mask for USB_INTEN_SOFTOKEN. */
#define BS_USB_INTEN_SOFTOKEN (1U)         /*!< Bit field size in bits for USB_INTEN_SOFTOKEN. */

/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define BR_USB_INTEN_SOFTOKEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN, BS_USB_INTEN_SOFTOKEN))

/*! @brief Format value for bitfield USB_INTEN_SOFTOKEN. */
#define BF_USB_INTEN_SOFTOKEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN) & BM_USB_INTEN_SOFTOKEN)

/*! @brief Set the SOFTOKEN field to a new value. */
#define BW_USB_INTEN_SOFTOKEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN), BP_USB_INTEN_SOFTOKEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the TOKDNE interrupt.
 * - 1 - Enables the TOKDNE interrupt.
 */
/*@{*/
#define BP_USB_INTEN_TOKDNEEN (3U)         /*!< Bit position for USB_INTEN_TOKDNEEN. */
#define BM_USB_INTEN_TOKDNEEN (0x08U)      /*!< Bit mask for USB_INTEN_TOKDNEEN. */
#define BS_USB_INTEN_TOKDNEEN (1U)         /*!< Bit field size in bits for USB_INTEN_TOKDNEEN. */

/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define BR_USB_INTEN_TOKDNEEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN, BS_USB_INTEN_TOKDNEEN))

/*! @brief Format value for bitfield USB_INTEN_TOKDNEEN. */
#define BF_USB_INTEN_TOKDNEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN) & BM_USB_INTEN_TOKDNEEN)

/*! @brief Set the TOKDNEEN field to a new value. */
#define BW_USB_INTEN_TOKDNEEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN), BP_USB_INTEN_TOKDNEEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - Disables the SLEEP interrupt.
 * - 1 - Enables the SLEEP interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SLEEPEN (4U)          /*!< Bit position for USB_INTEN_SLEEPEN. */
#define BM_USB_INTEN_SLEEPEN (0x10U)       /*!< Bit mask for USB_INTEN_SLEEPEN. */
#define BS_USB_INTEN_SLEEPEN (1U)          /*!< Bit field size in bits for USB_INTEN_SLEEPEN. */

/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define BR_USB_INTEN_SLEEPEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN, BS_USB_INTEN_SLEEPEN))

/*! @brief Format value for bitfield USB_INTEN_SLEEPEN. */
#define BF_USB_INTEN_SLEEPEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SLEEPEN) & BM_USB_INTEN_SLEEPEN)

/*! @brief Set the SLEEPEN field to a new value. */
#define BW_USB_INTEN_SLEEPEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_SLEEPEN), BP_USB_INTEN_SLEEPEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the RESUME interrupt.
 * - 1 - Enables the RESUME interrupt.
 */
/*@{*/
#define BP_USB_INTEN_RESUMEEN (5U)         /*!< Bit position for USB_INTEN_RESUMEEN. */
#define BM_USB_INTEN_RESUMEEN (0x20U)      /*!< Bit mask for USB_INTEN_RESUMEEN. */
#define BS_USB_INTEN_RESUMEEN (1U)         /*!< Bit field size in bits for USB_INTEN_RESUMEEN. */

/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define BR_USB_INTEN_RESUMEEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN, BS_USB_INTEN_RESUMEEN))

/*! @brief Format value for bitfield USB_INTEN_RESUMEEN. */
#define BF_USB_INTEN_RESUMEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_RESUMEEN) & BM_USB_INTEN_RESUMEEN)

/*! @brief Set the RESUMEEN field to a new value. */
#define BW_USB_INTEN_RESUMEEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_RESUMEEN), BP_USB_INTEN_RESUMEEN, 1))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - Diasbles the STALL interrupt.
 * - 1 - Enables the STALL interrupt.
 */
/*@{*/
#define BP_USB_INTEN_STALLEN (7U)          /*!< Bit position for USB_INTEN_STALLEN. */
#define BM_USB_INTEN_STALLEN (0x80U)       /*!< Bit mask for USB_INTEN_STALLEN. */
#define BS_USB_INTEN_STALLEN (1U)          /*!< Bit field size in bits for USB_INTEN_STALLEN. */

/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define BR_USB_INTEN_STALLEN(x) (BME_UBFX8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN, BS_USB_INTEN_STALLEN))

/*! @brief Format value for bitfield USB_INTEN_STALLEN. */
#define BF_USB_INTEN_STALLEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_STALLEN) & BM_USB_INTEN_STALLEN)

/*! @brief Set the STALLEN field to a new value. */
#define BW_USB_INTEN_STALLEN(x, v) (BME_BFI8(HW_USB_INTEN_ADDR(x), ((uint8_t)(v) << BP_USB_INTEN_STALLEN), BP_USB_INTEN_STALLEN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERRSTAT - Error Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_errstat
{
    uint8_t U;
    struct _hw_usb_errstat_bitfields
    {
        uint8_t PIDERR : 1;            /*!< [0]  */
        uint8_t CRC5 : 1;              /*!< [1]  */
        uint8_t CRC16 : 1;             /*!< [2]  */
        uint8_t DFN8 : 1;              /*!< [3]  */
        uint8_t BTOERR : 1;            /*!< [4]  */
        uint8_t DMAERR : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERR : 1;            /*!< [7]  */
    } B;
} hw_usb_errstat_t;

/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define HW_USB_ERRSTAT_ADDR(x)   ((x) + 0x88U)

#define HW_USB_ERRSTAT(x)        (*(__IO hw_usb_errstat_t *) HW_USB_ERRSTAT_ADDR(x))
#define HW_USB_ERRSTAT_RD(x)     (HW_USB_ERRSTAT(x).U)
#define HW_USB_ERRSTAT_WR(x, v)  (HW_USB_ERRSTAT(x).U = (v))
#define HW_USB_ERRSTAT_SET(x, v) (BME_OR8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(v)))
#define HW_USB_ERRSTAT_CLR(x, v) (BME_AND8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ERRSTAT_TOG(x, v) (BME_XOR8(HW_USB_ERRSTAT_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
#define BP_USB_ERRSTAT_PIDERR (0U)         /*!< Bit position for USB_ERRSTAT_PIDERR. */
#define BM_USB_ERRSTAT_PIDERR (0x01U)      /*!< Bit mask for USB_ERRSTAT_PIDERR. */
#define BS_USB_ERRSTAT_PIDERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_PIDERR. */

/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define BR_USB_ERRSTAT_PIDERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR, BS_USB_ERRSTAT_PIDERR))

/*! @brief Format value for bitfield USB_ERRSTAT_PIDERR. */
#define BF_USB_ERRSTAT_PIDERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR) & BM_USB_ERRSTAT_PIDERR)

/*! @brief Set the PIDERR field to a new value. */
#define BW_USB_ERRSTAT_PIDERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR), BP_USB_ERRSTAT_PIDERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token
 * packets generated by the host. If set the token packet was rejected due to a
 * CRC5 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC5  (1U)          /*!< Bit position for USB_ERRSTAT_CRC5. */
#define BM_USB_ERRSTAT_CRC5  (0x02U)       /*!< Bit mask for USB_ERRSTAT_CRC5. */
#define BS_USB_ERRSTAT_CRC5  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC5. */

/*! @brief Read current value of the USB_ERRSTAT_CRC5 field. */
#define BR_USB_ERRSTAT_CRC5(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5, BS_USB_ERRSTAT_CRC5))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC5. */
#define BF_USB_ERRSTAT_CRC5(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC5) & BM_USB_ERRSTAT_CRC5)

/*! @brief Set the CRC5 field to a new value. */
#define BW_USB_ERRSTAT_CRC5(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_CRC5), BP_USB_ERRSTAT_CRC5, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC16 (2U)          /*!< Bit position for USB_ERRSTAT_CRC16. */
#define BM_USB_ERRSTAT_CRC16 (0x04U)       /*!< Bit mask for USB_ERRSTAT_CRC16. */
#define BS_USB_ERRSTAT_CRC16 (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC16. */

/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define BR_USB_ERRSTAT_CRC16(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16, BS_USB_ERRSTAT_CRC16))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC16. */
#define BF_USB_ERRSTAT_CRC16(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC16) & BM_USB_ERRSTAT_CRC16)

/*! @brief Set the CRC16 field to a new value. */
#define BW_USB_ERRSTAT_CRC16(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_CRC16), BP_USB_ERRSTAT_CRC16, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
#define BP_USB_ERRSTAT_DFN8  (3U)          /*!< Bit position for USB_ERRSTAT_DFN8. */
#define BM_USB_ERRSTAT_DFN8  (0x08U)       /*!< Bit mask for USB_ERRSTAT_DFN8. */
#define BS_USB_ERRSTAT_DFN8  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_DFN8. */

/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define BR_USB_ERRSTAT_DFN8(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8, BS_USB_ERRSTAT_DFN8))

/*! @brief Format value for bitfield USB_ERRSTAT_DFN8. */
#define BF_USB_ERRSTAT_DFN8(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DFN8) & BM_USB_ERRSTAT_DFN8)

/*! @brief Set the DFN8 field to a new value. */
#define BW_USB_ERRSTAT_DFN8(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_DFN8), BP_USB_ERRSTAT_DFN8, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTOERR (4U)         /*!< Bit position for USB_ERRSTAT_BTOERR. */
#define BM_USB_ERRSTAT_BTOERR (0x10U)      /*!< Bit mask for USB_ERRSTAT_BTOERR. */
#define BS_USB_ERRSTAT_BTOERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTOERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define BR_USB_ERRSTAT_BTOERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR, BS_USB_ERRSTAT_BTOERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTOERR. */
#define BF_USB_ERRSTAT_BTOERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR) & BM_USB_ERRSTAT_BTOERR)

/*! @brief Set the BTOERR field to a new value. */
#define BW_USB_ERRSTAT_BTOERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR), BP_USB_ERRSTAT_BTOERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
#define BP_USB_ERRSTAT_DMAERR (5U)         /*!< Bit position for USB_ERRSTAT_DMAERR. */
#define BM_USB_ERRSTAT_DMAERR (0x20U)      /*!< Bit mask for USB_ERRSTAT_DMAERR. */
#define BS_USB_ERRSTAT_DMAERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_DMAERR. */

/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define BR_USB_ERRSTAT_DMAERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR, BS_USB_ERRSTAT_DMAERR))

/*! @brief Format value for bitfield USB_ERRSTAT_DMAERR. */
#define BF_USB_ERRSTAT_DMAERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR) & BM_USB_ERRSTAT_DMAERR)

/*! @brief Set the DMAERR field to a new value. */
#define BW_USB_ERRSTAT_DMAERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR), BP_USB_ERRSTAT_DMAERR, 1))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTSERR (7U)         /*!< Bit position for USB_ERRSTAT_BTSERR. */
#define BM_USB_ERRSTAT_BTSERR (0x80U)      /*!< Bit mask for USB_ERRSTAT_BTSERR. */
#define BS_USB_ERRSTAT_BTSERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTSERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define BR_USB_ERRSTAT_BTSERR(x) (BME_UBFX8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR, BS_USB_ERRSTAT_BTSERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTSERR. */
#define BF_USB_ERRSTAT_BTSERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR) & BM_USB_ERRSTAT_BTSERR)

/*! @brief Set the BTSERR field to a new value. */
#define BW_USB_ERRSTAT_BTSERR(x, v) (BME_BFI8(HW_USB_ERRSTAT_ADDR(x), ((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR), BP_USB_ERRSTAT_BTSERR, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_erren
{
    uint8_t U;
    struct _hw_usb_erren_bitfields
    {
        uint8_t PIDERREN : 1;          /*!< [0] PIDERR Interrupt Enable */
        uint8_t CRC5EOFEN : 1;         /*!< [1] CRC5/EOF Interrupt Enable */
        uint8_t CRC16EN : 1;           /*!< [2] CRC16 Interrupt Enable */
        uint8_t DFN8EN : 1;            /*!< [3] DFN8 Interrupt Enable */
        uint8_t BTOERREN : 1;          /*!< [4] BTOERR Interrupt Enable */
        uint8_t DMAERREN : 1;          /*!< [5] DMAERR Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERREN : 1;          /*!< [7] BTSERR Interrupt Enable */
    } B;
} hw_usb_erren_t;

/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define HW_USB_ERREN_ADDR(x)     ((x) + 0x8CU)

#define HW_USB_ERREN(x)          (*(__IO hw_usb_erren_t *) HW_USB_ERREN_ADDR(x))
#define HW_USB_ERREN_RD(x)       (HW_USB_ERREN(x).U)
#define HW_USB_ERREN_WR(x, v)    (HW_USB_ERREN(x).U = (v))
#define HW_USB_ERREN_SET(x, v)   (BME_OR8(HW_USB_ERREN_ADDR(x), (uint8_t)(v)))
#define HW_USB_ERREN_CLR(x, v)   (BME_AND8(HW_USB_ERREN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ERREN_TOG(x, v)   (BME_XOR8(HW_USB_ERREN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - Disables the PIDERR interrupt.
 * - 1 - Enters the PIDERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_PIDERREN (0U)         /*!< Bit position for USB_ERREN_PIDERREN. */
#define BM_USB_ERREN_PIDERREN (0x01U)      /*!< Bit mask for USB_ERREN_PIDERREN. */
#define BS_USB_ERREN_PIDERREN (1U)         /*!< Bit field size in bits for USB_ERREN_PIDERREN. */

/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define BR_USB_ERREN_PIDERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN, BS_USB_ERREN_PIDERREN))

/*! @brief Format value for bitfield USB_ERREN_PIDERREN. */
#define BF_USB_ERREN_PIDERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_PIDERREN) & BM_USB_ERREN_PIDERREN)

/*! @brief Set the PIDERREN field to a new value. */
#define BW_USB_ERREN_PIDERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_PIDERREN), BP_USB_ERREN_PIDERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - Disables the CRC5/EOF interrupt.
 * - 1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit position for USB_ERREN_CRC5EOFEN. */
#define BM_USB_ERREN_CRC5EOFEN (0x02U)     /*!< Bit mask for USB_ERREN_CRC5EOFEN. */
#define BS_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit field size in bits for USB_ERREN_CRC5EOFEN. */

/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define BR_USB_ERREN_CRC5EOFEN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN, BS_USB_ERREN_CRC5EOFEN))

/*! @brief Format value for bitfield USB_ERREN_CRC5EOFEN. */
#define BF_USB_ERREN_CRC5EOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN) & BM_USB_ERREN_CRC5EOFEN)

/*! @brief Set the CRC5EOFEN field to a new value. */
#define BW_USB_ERREN_CRC5EOFEN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN), BP_USB_ERREN_CRC5EOFEN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - Disables the CRC16 interrupt.
 * - 1 - Enables the CRC16 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC16EN (2U)          /*!< Bit position for USB_ERREN_CRC16EN. */
#define BM_USB_ERREN_CRC16EN (0x04U)       /*!< Bit mask for USB_ERREN_CRC16EN. */
#define BS_USB_ERREN_CRC16EN (1U)          /*!< Bit field size in bits for USB_ERREN_CRC16EN. */

/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define BR_USB_ERREN_CRC16EN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN, BS_USB_ERREN_CRC16EN))

/*! @brief Format value for bitfield USB_ERREN_CRC16EN. */
#define BF_USB_ERREN_CRC16EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC16EN) & BM_USB_ERREN_CRC16EN)

/*! @brief Set the CRC16EN field to a new value. */
#define BW_USB_ERREN_CRC16EN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_CRC16EN), BP_USB_ERREN_CRC16EN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - Disables the DFN8 interrupt.
 * - 1 - Enables the DFN8 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DFN8EN  (3U)          /*!< Bit position for USB_ERREN_DFN8EN. */
#define BM_USB_ERREN_DFN8EN  (0x08U)       /*!< Bit mask for USB_ERREN_DFN8EN. */
#define BS_USB_ERREN_DFN8EN  (1U)          /*!< Bit field size in bits for USB_ERREN_DFN8EN. */

/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define BR_USB_ERREN_DFN8EN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN, BS_USB_ERREN_DFN8EN))

/*! @brief Format value for bitfield USB_ERREN_DFN8EN. */
#define BF_USB_ERREN_DFN8EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DFN8EN) & BM_USB_ERREN_DFN8EN)

/*! @brief Set the DFN8EN field to a new value. */
#define BW_USB_ERREN_DFN8EN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_DFN8EN), BP_USB_ERREN_DFN8EN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - Disables the BTOERR interrupt.
 * - 1 - Enables the BTOERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTOERREN (4U)         /*!< Bit position for USB_ERREN_BTOERREN. */
#define BM_USB_ERREN_BTOERREN (0x10U)      /*!< Bit mask for USB_ERREN_BTOERREN. */
#define BS_USB_ERREN_BTOERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTOERREN. */

/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define BR_USB_ERREN_BTOERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN, BS_USB_ERREN_BTOERREN))

/*! @brief Format value for bitfield USB_ERREN_BTOERREN. */
#define BF_USB_ERREN_BTOERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTOERREN) & BM_USB_ERREN_BTOERREN)

/*! @brief Set the BTOERREN field to a new value. */
#define BW_USB_ERREN_BTOERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_BTOERREN), BP_USB_ERREN_BTOERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - Disables the DMAERR interrupt.
 * - 1 - Enables the DMAERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DMAERREN (5U)         /*!< Bit position for USB_ERREN_DMAERREN. */
#define BM_USB_ERREN_DMAERREN (0x20U)      /*!< Bit mask for USB_ERREN_DMAERREN. */
#define BS_USB_ERREN_DMAERREN (1U)         /*!< Bit field size in bits for USB_ERREN_DMAERREN. */

/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define BR_USB_ERREN_DMAERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN, BS_USB_ERREN_DMAERREN))

/*! @brief Format value for bitfield USB_ERREN_DMAERREN. */
#define BF_USB_ERREN_DMAERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DMAERREN) & BM_USB_ERREN_DMAERREN)

/*! @brief Set the DMAERREN field to a new value. */
#define BW_USB_ERREN_DMAERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_DMAERREN), BP_USB_ERREN_DMAERREN, 1))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - Disables the BTSERR interrupt.
 * - 1 - Enables the BTSERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTSERREN (7U)         /*!< Bit position for USB_ERREN_BTSERREN. */
#define BM_USB_ERREN_BTSERREN (0x80U)      /*!< Bit mask for USB_ERREN_BTSERREN. */
#define BS_USB_ERREN_BTSERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTSERREN. */

/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define BR_USB_ERREN_BTSERREN(x) (BME_UBFX8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN, BS_USB_ERREN_BTSERREN))

/*! @brief Format value for bitfield USB_ERREN_BTSERREN. */
#define BF_USB_ERREN_BTSERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTSERREN) & BM_USB_ERREN_BTSERREN)

/*! @brief Set the BTSERREN field to a new value. */
#define BW_USB_ERREN_BTSERREN(x, v) (BME_BFI8(HW_USB_ERREN_ADDR(x), ((uint8_t)(v) << BP_USB_ERREN_BTSERREN), BP_USB_ERREN_BTSERREN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
typedef union _hw_usb_stat
{
    uint8_t U;
    struct _hw_usb_stat_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t ODD : 1;               /*!< [2]  */
        uint8_t TX : 1;                /*!< [3] Transmit Indicator */
        uint8_t ENDP : 4;              /*!< [7:4]  */
    } B;
} hw_usb_stat_t;

/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define HW_USB_STAT_ADDR(x)      ((x) + 0x90U)

#define HW_USB_STAT(x)           (*(__I hw_usb_stat_t *) HW_USB_STAT_ADDR(x))
#define HW_USB_STAT_RD(x)        (HW_USB_STAT(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
#define BP_USB_STAT_ODD      (2U)          /*!< Bit position for USB_STAT_ODD. */
#define BM_USB_STAT_ODD      (0x04U)       /*!< Bit mask for USB_STAT_ODD. */
#define BS_USB_STAT_ODD      (1U)          /*!< Bit field size in bits for USB_STAT_ODD. */

/*! @brief Read current value of the USB_STAT_ODD field. */
#define BR_USB_STAT_ODD(x)   (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ODD, BS_USB_STAT_ODD))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a receive operation.
 * - 1 - The most recent transaction was a transmit operation.
 */
/*@{*/
#define BP_USB_STAT_TX       (3U)          /*!< Bit position for USB_STAT_TX. */
#define BM_USB_STAT_TX       (0x08U)       /*!< Bit mask for USB_STAT_TX. */
#define BS_USB_STAT_TX       (1U)          /*!< Bit field size in bits for USB_STAT_TX. */

/*! @brief Read current value of the USB_STAT_TX field. */
#define BR_USB_STAT_TX(x)    (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_TX, BS_USB_STAT_TX))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
#define BP_USB_STAT_ENDP     (4U)          /*!< Bit position for USB_STAT_ENDP. */
#define BM_USB_STAT_ENDP     (0xF0U)       /*!< Bit mask for USB_STAT_ENDP. */
#define BS_USB_STAT_ENDP     (4U)          /*!< Bit field size in bits for USB_STAT_ENDP. */

/*! @brief Read current value of the USB_STAT_ENDP field. */
#define BR_USB_STAT_ENDP(x)  (BME_UBFX8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ENDP, BS_USB_STAT_ENDP))
/*@}*/

/*******************************************************************************
 * HW_USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
typedef union _hw_usb_ctl
{
    uint8_t U;
    struct _hw_usb_ctl_bitfields
    {
        uint8_t USBENSOFEN : 1;        /*!< [0] USB Enable */
        uint8_t ODDRST : 1;            /*!< [1]  */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t TXSUSPENDTOKENBUSY : 1; /*!< [5]  */
        uint8_t SE0 : 1;               /*!< [6] Live USB Single Ended Zero signal */
        uint8_t JSTATE : 1;            /*!< [7] Live USB differential receiver JSTATE
                                        * signal */
    } B;
} hw_usb_ctl_t;

/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define HW_USB_CTL_ADDR(x)       ((uint32_t)(x) + 0x94U)

#define HW_USB_CTL(x)            (*(__IO hw_usb_ctl_t *) HW_USB_CTL_ADDR(x))
#define HW_USB_CTL_RD(x)         (HW_USB_CTL(x).U)
#define HW_USB_CTL_WR(x, v)      (HW_USB_CTL(x).U = (v))
#define HW_USB_CTL_SET(x, v)     (BME_OR8(HW_USB_CTL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CTL_CLR(x, v)     (BME_AND8(HW_USB_CTL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CTL_TOG(x, v)     (BME_XOR8(HW_USB_CTL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE.
 *
 * Values:
 * - 0 - Disables the USB Module.
 * - 1 - Enables the USB Module.
 */
/*@{*/
#define BP_USB_CTL_USBENSOFEN (0U)         /*!< Bit position for USB_CTL_USBENSOFEN. */
#define BM_USB_CTL_USBENSOFEN (0x01U)      /*!< Bit mask for USB_CTL_USBENSOFEN. */
#define BS_USB_CTL_USBENSOFEN (1U)         /*!< Bit field size in bits for USB_CTL_USBENSOFEN. */

/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define BR_USB_CTL_USBENSOFEN(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN, BS_USB_CTL_USBENSOFEN))

/*! @brief Format value for bitfield USB_CTL_USBENSOFEN. */
#define BF_USB_CTL_USBENSOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_USBENSOFEN) & BM_USB_CTL_USBENSOFEN)

/*! @brief Set the USBENSOFEN field to a new value. */
#define BW_USB_CTL_USBENSOFEN(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_USBENSOFEN), BP_USB_CTL_USBENSOFEN, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
#define BP_USB_CTL_ODDRST    (1U)          /*!< Bit position for USB_CTL_ODDRST. */
#define BM_USB_CTL_ODDRST    (0x02U)       /*!< Bit mask for USB_CTL_ODDRST. */
#define BS_USB_CTL_ODDRST    (1U)          /*!< Bit field size in bits for USB_CTL_ODDRST. */

/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define BR_USB_CTL_ODDRST(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST, BS_USB_CTL_ODDRST))

/*! @brief Format value for bitfield USB_CTL_ODDRST. */
#define BF_USB_CTL_ODDRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_ODDRST) & BM_USB_CTL_ODDRST)

/*! @brief Set the ODDRST field to a new value. */
#define BW_USB_CTL_ODDRST(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_ODDRST), BP_USB_CTL_ODDRST, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Target mode, TXD_SUSPEND is set when the SIE has disabled packet
 * transmission and reception. Clearing this bit allows the SIE to continue token
 * processing. This bit is set by the SIE when a SETUP Token is received allowing
 * software to dequeue any pending packet transactions in the BDT before resuming token
 * processing.
 */
/*@{*/
#define BP_USB_CTL_TXSUSPENDTOKENBUSY (5U) /*!< Bit position for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BM_USB_CTL_TXSUSPENDTOKENBUSY (0x20U) /*!< Bit mask for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BS_USB_CTL_TXSUSPENDTOKENBUSY (1U) /*!< Bit field size in bits for USB_CTL_TXSUSPENDTOKENBUSY. */

/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define BR_USB_CTL_TXSUSPENDTOKENBUSY(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY, BS_USB_CTL_TXSUSPENDTOKENBUSY))

/*! @brief Format value for bitfield USB_CTL_TXSUSPENDTOKENBUSY. */
#define BF_USB_CTL_TXSUSPENDTOKENBUSY(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY) & BM_USB_CTL_TXSUSPENDTOKENBUSY)

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define BW_USB_CTL_TXSUSPENDTOKENBUSY(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY), BP_USB_CTL_TXSUSPENDTOKENBUSY, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
#define BP_USB_CTL_SE0       (6U)          /*!< Bit position for USB_CTL_SE0. */
#define BM_USB_CTL_SE0       (0x40U)       /*!< Bit mask for USB_CTL_SE0. */
#define BS_USB_CTL_SE0       (1U)          /*!< Bit field size in bits for USB_CTL_SE0. */

/*! @brief Read current value of the USB_CTL_SE0 field. */
#define BR_USB_CTL_SE0(x)    (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0, BS_USB_CTL_SE0))

/*! @brief Format value for bitfield USB_CTL_SE0. */
#define BF_USB_CTL_SE0(v)    ((uint8_t)((uint8_t)(v) << BP_USB_CTL_SE0) & BM_USB_CTL_SE0)

/*! @brief Set the SE0 field to a new value. */
#define BW_USB_CTL_SE0(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_SE0), BP_USB_CTL_SE0, 1))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
#define BP_USB_CTL_JSTATE    (7U)          /*!< Bit position for USB_CTL_JSTATE. */
#define BM_USB_CTL_JSTATE    (0x80U)       /*!< Bit mask for USB_CTL_JSTATE. */
#define BS_USB_CTL_JSTATE    (1U)          /*!< Bit field size in bits for USB_CTL_JSTATE. */

/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define BR_USB_CTL_JSTATE(x) (BME_UBFX8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE, BS_USB_CTL_JSTATE))

/*! @brief Format value for bitfield USB_CTL_JSTATE. */
#define BF_USB_CTL_JSTATE(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_JSTATE) & BM_USB_CTL_JSTATE)

/*! @brief Set the JSTATE field to a new value. */
#define BW_USB_CTL_JSTATE(x, v) (BME_BFI8(HW_USB_CTL_ADDR(x), ((uint8_t)(v) << BP_USB_CTL_JSTATE), BP_USB_CTL_JSTATE, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (HOSTMODEEN=0). CTL[USBENSOFEN] must be 1. The Address register is reset
 * to 0x00 after the reset input becomes active or the USB module decodes a USB
 * reset signal. This action initializes the Address register to decode address
 * 0x00 as required by the USB specification.
 */
typedef union _hw_usb_addr
{
    uint8_t U;
    struct _hw_usb_addr_bitfields
    {
        uint8_t ADDR : 7;              /*!< [6:0] USB Address */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_usb_addr_t;

/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define HW_USB_ADDR_ADDR(x)      ((x) + 0x98U)

#define HW_USB_ADDR(x)           (*(__IO hw_usb_addr_t *) HW_USB_ADDR_ADDR(x))
#define HW_USB_ADDR_RD(x)        (HW_USB_ADDR(x).U)
#define HW_USB_ADDR_WR(x, v)     (HW_USB_ADDR(x).U = (v))
#define HW_USB_ADDR_SET(x, v)    (BME_OR8(HW_USB_ADDR_ADDR(x), (uint8_t)(v)))
#define HW_USB_ADDR_CLR(x, v)    (BME_AND8(HW_USB_ADDR_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_ADDR_TOG(x, v)    (BME_XOR8(HW_USB_ADDR_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode.
 */
/*@{*/
#define BP_USB_ADDR_ADDR     (0U)          /*!< Bit position for USB_ADDR_ADDR. */
#define BM_USB_ADDR_ADDR     (0x7FU)       /*!< Bit mask for USB_ADDR_ADDR. */
#define BS_USB_ADDR_ADDR     (7U)          /*!< Bit field size in bits for USB_ADDR_ADDR. */

/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define BR_USB_ADDR_ADDR(x)  (BME_UBFX8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_ADDR, BS_USB_ADDR_ADDR))

/*! @brief Format value for bitfield USB_ADDR_ADDR. */
#define BF_USB_ADDR_ADDR(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_ADDR) & BM_USB_ADDR_ADDR)

/*! @brief Set the ADDR field to a new value. */
#define BW_USB_ADDR_ADDR(x, v) (BME_BFI8(HW_USB_ADDR_ADDR(x), ((uint8_t)(v) << BP_USB_ADDR_ADDR), BP_USB_ADDR_ADDR, 7))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. See Buffer Descriptor
 * Table. The 32-bit BDT Base Address is always aligned on 512-byte boundaries, so
 * bits 8 through 0 of the base address are always zero.
 */
typedef union _hw_usb_bdtpage1
{
    uint8_t U;
    struct _hw_usb_bdtpage1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t BDTBA : 7;             /*!< [7:1]  */
    } B;
} hw_usb_bdtpage1_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define HW_USB_BDTPAGE1_ADDR(x)  ((x) + 0x9CU)

#define HW_USB_BDTPAGE1(x)       (*(__IO hw_usb_bdtpage1_t *) HW_USB_BDTPAGE1_ADDR(x))
#define HW_USB_BDTPAGE1_RD(x)    (HW_USB_BDTPAGE1(x).U)
#define HW_USB_BDTPAGE1_WR(x, v) (HW_USB_BDTPAGE1(x).U = (v))
#define HW_USB_BDTPAGE1_SET(x, v) (BME_OR8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE1_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE1_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
#define BP_USB_BDTPAGE1_BDTBA (1U)         /*!< Bit position for USB_BDTPAGE1_BDTBA. */
#define BM_USB_BDTPAGE1_BDTBA (0xFEU)      /*!< Bit mask for USB_BDTPAGE1_BDTBA. */
#define BS_USB_BDTPAGE1_BDTBA (7U)         /*!< Bit field size in bits for USB_BDTPAGE1_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define BR_USB_BDTPAGE1_BDTBA(x) (BME_UBFX8(HW_USB_BDTPAGE1_ADDR(x), BP_USB_BDTPAGE1_BDTBA, BS_USB_BDTPAGE1_BDTBA))

/*! @brief Format value for bitfield USB_BDTPAGE1_BDTBA. */
#define BF_USB_BDTPAGE1_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA) & BM_USB_BDTPAGE1_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE1_BDTBA(x, v) (BME_BFI8(HW_USB_BDTPAGE1_ADDR(x), ((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA), BP_USB_BDTPAGE1_BDTBA, 7))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnuml
{
    uint8_t U;
    struct _hw_usb_frmnuml_bitfields
    {
        uint8_t FRM : 8;               /*!< [7:0]  */
    } B;
} hw_usb_frmnuml_t;

/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define HW_USB_FRMNUML_ADDR(x)   ((x) + 0xA0U)

#define HW_USB_FRMNUML(x)        (*(__IO hw_usb_frmnuml_t *) HW_USB_FRMNUML_ADDR(x))
#define HW_USB_FRMNUML_RD(x)     (HW_USB_FRMNUML(x).U)
#define HW_USB_FRMNUML_WR(x, v)  (HW_USB_FRMNUML(x).U = (v))
#define HW_USB_FRMNUML_SET(x, v) (BME_OR8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(v)))
#define HW_USB_FRMNUML_CLR(x, v) (BME_AND8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_FRMNUML_TOG(x, v) (BME_XOR8(HW_USB_FRMNUML_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUML bitfields
 */

/*!
 * @name Register USB_FRMNUML, field FRM[7:0] (RW)
 *
 * This 8-bit field and the 3-bit field in the Frame Number Register High are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUML_FRM   (0U)          /*!< Bit position for USB_FRMNUML_FRM. */
#define BM_USB_FRMNUML_FRM   (0xFFU)       /*!< Bit mask for USB_FRMNUML_FRM. */
#define BS_USB_FRMNUML_FRM   (8U)          /*!< Bit field size in bits for USB_FRMNUML_FRM. */

/*! @brief Read current value of the USB_FRMNUML_FRM field. */
#define BR_USB_FRMNUML_FRM(x) (HW_USB_FRMNUML(x).U)

/*! @brief Format value for bitfield USB_FRMNUML_FRM. */
#define BF_USB_FRMNUML_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUML_FRM) & BM_USB_FRMNUML_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUML_FRM(x, v) (HW_USB_FRMNUML_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnumh
{
    uint8_t U;
    struct _hw_usb_frmnumh_bitfields
    {
        uint8_t FRM : 3;               /*!< [2:0]  */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_usb_frmnumh_t;

/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define HW_USB_FRMNUMH_ADDR(x)   ((x) + 0xA4U)

#define HW_USB_FRMNUMH(x)        (*(__IO hw_usb_frmnumh_t *) HW_USB_FRMNUMH_ADDR(x))
#define HW_USB_FRMNUMH_RD(x)     (HW_USB_FRMNUMH(x).U)
#define HW_USB_FRMNUMH_WR(x, v)  (HW_USB_FRMNUMH(x).U = (v))
#define HW_USB_FRMNUMH_SET(x, v) (BME_OR8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(v)))
#define HW_USB_FRMNUMH_CLR(x, v) (BME_AND8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_FRMNUMH_TOG(x, v) (BME_XOR8(HW_USB_FRMNUMH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUMH_FRM   (0U)          /*!< Bit position for USB_FRMNUMH_FRM. */
#define BM_USB_FRMNUMH_FRM   (0x07U)       /*!< Bit mask for USB_FRMNUMH_FRM. */
#define BS_USB_FRMNUMH_FRM   (3U)          /*!< Bit field size in bits for USB_FRMNUMH_FRM. */

/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define BR_USB_FRMNUMH_FRM(x) (BME_UBFX8(HW_USB_FRMNUMH_ADDR(x), BP_USB_FRMNUMH_FRM, BS_USB_FRMNUMH_FRM))

/*! @brief Format value for bitfield USB_FRMNUMH_FRM. */
#define BF_USB_FRMNUMH_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUMH_FRM) & BM_USB_FRMNUMH_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUMH_FRM(x, v) (BME_BFI8(HW_USB_FRMNUMH_ADDR(x), ((uint8_t)(v) << BP_USB_FRMNUMH_FRM), BP_USB_FRMNUMH_FRM, 3))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage2
{
    uint8_t U;
    struct _hw_usb_bdtpage2_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage2_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define HW_USB_BDTPAGE2_ADDR(x)  ((x) + 0xB0U)

#define HW_USB_BDTPAGE2(x)       (*(__IO hw_usb_bdtpage2_t *) HW_USB_BDTPAGE2_ADDR(x))
#define HW_USB_BDTPAGE2_RD(x)    (HW_USB_BDTPAGE2(x).U)
#define HW_USB_BDTPAGE2_WR(x, v) (HW_USB_BDTPAGE2(x).U = (v))
#define HW_USB_BDTPAGE2_SET(x, v) (BME_OR8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE2_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE2_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE2 bitfields
 */

/*!
 * @name Register USB_BDTPAGE2, field BDTBA[7:0] (RW)
 *
 * Provides address bits 23 through 16 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE2_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE2_BDTBA. */
#define BM_USB_BDTPAGE2_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE2_BDTBA. */
#define BS_USB_BDTPAGE2_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE2_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE2_BDTBA field. */
#define BR_USB_BDTPAGE2_BDTBA(x) (HW_USB_BDTPAGE2(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE2_BDTBA. */
#define BF_USB_BDTPAGE2_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE2_BDTBA) & BM_USB_BDTPAGE2_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE2_BDTBA(x, v) (HW_USB_BDTPAGE2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage3
{
    uint8_t U;
    struct _hw_usb_bdtpage3_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage3_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define HW_USB_BDTPAGE3_ADDR(x)  ((x) + 0xB4U)

#define HW_USB_BDTPAGE3(x)       (*(__IO hw_usb_bdtpage3_t *) HW_USB_BDTPAGE3_ADDR(x))
#define HW_USB_BDTPAGE3_RD(x)    (HW_USB_BDTPAGE3(x).U)
#define HW_USB_BDTPAGE3_WR(x, v) (HW_USB_BDTPAGE3(x).U = (v))
#define HW_USB_BDTPAGE3_SET(x, v) (BME_OR8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(v)))
#define HW_USB_BDTPAGE3_CLR(x, v) (BME_AND8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_BDTPAGE3_TOG(x, v) (BME_XOR8(HW_USB_BDTPAGE3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE3 bitfields
 */

/*!
 * @name Register USB_BDTPAGE3, field BDTBA[7:0] (RW)
 *
 * Provides address bits 31 through 24 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE3_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE3_BDTBA. */
#define BM_USB_BDTPAGE3_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE3_BDTBA. */
#define BS_USB_BDTPAGE3_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE3_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE3_BDTBA field. */
#define BR_USB_BDTPAGE3_BDTBA(x) (HW_USB_BDTPAGE3(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE3_BDTBA. */
#define BF_USB_BDTPAGE3_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE3_BDTBA) & BM_USB_BDTPAGE3_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE3_BDTBA(x, v) (HW_USB_BDTPAGE3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_ENDPTn - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_ENDPTn - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. The three
 * bits EPCTLDIS, EPRXEN, and EPTXEN define if an endpoint is enabled and define
 * the direction of the endpoint. The endpoint enable/direction control is defined
 * in the following table. Endpoint enable and direction control EPCTLDIS EPRXEN
 * EPTXEN Endpoint enable/direction control X 0 0 Disable endpoint X 0 1 Enable
 * endpoint for Tx transfers only X 1 0 Enable endpoint for Rx transfers only 1 1
 * 1 Enable endpoint for Rx and Tx transfers 0 1 1 Enable Endpoint for RX and TX
 * as well as control (SETUP) transfers.
 */
typedef union _hw_usb_endptn
{
    uint8_t U;
    struct _hw_usb_endptn_bitfields
    {
        uint8_t EPHSHK : 1;            /*!< [0]  */
        uint8_t EPSTALL : 1;           /*!< [1]  */
        uint8_t EPTXEN : 1;            /*!< [2]  */
        uint8_t EPRXEN : 1;            /*!< [3]  */
        uint8_t EPCTLDIS : 1;          /*!< [4]  */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_endptn_t;

/*!
 * @name Constants and macros for entire USB_ENDPTn register
 */
/*@{*/
#define HW_USB_ENDPTn_COUNT (16U)

#define HW_USB_ENDPTn_ADDR(x, n) ((x) + 0xC0U + (0x4U * (n)))

#define HW_USB_ENDPTn(x, n)      (*(__IO hw_usb_endptn_t *) HW_USB_ENDPTn_ADDR(x, n))
#define HW_USB_ENDPTn_RD(x, n)   (HW_USB_ENDPTn(x, n).U)
#define HW_USB_ENDPTn_WR(x, n, v) (HW_USB_ENDPTn(x, n).U = (v))
#define HW_USB_ENDPTn_SET(x, n, v) (BME_OR8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(v)))
#define HW_USB_ENDPTn_CLR(x, n, v) (BME_AND8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(~(v))))
#define HW_USB_ENDPTn_TOG(x, n, v) (BME_XOR8(HW_USB_ENDPTn_ADDR(x, n), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPTn bitfields
 */

/*!
 * @name Register USB_ENDPTn, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
#define BP_USB_ENDPTn_EPHSHK (0U)          /*!< Bit position for USB_ENDPTn_EPHSHK. */
#define BM_USB_ENDPTn_EPHSHK (0x01U)       /*!< Bit mask for USB_ENDPTn_EPHSHK. */
#define BS_USB_ENDPTn_EPHSHK (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPHSHK. */

/*! @brief Read current value of the USB_ENDPTn_EPHSHK field. */
#define BR_USB_ENDPTn_EPHSHK(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK, BS_USB_ENDPTn_EPHSHK))

/*! @brief Format value for bitfield USB_ENDPTn_EPHSHK. */
#define BF_USB_ENDPTn_EPHSHK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK) & BM_USB_ENDPTn_EPHSHK)

/*! @brief Set the EPHSHK field to a new value. */
#define BW_USB_ENDPTn_EPHSHK(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK), BP_USB_ENDPTn_EPHSHK, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
#define BP_USB_ENDPTn_EPSTALL (1U)         /*!< Bit position for USB_ENDPTn_EPSTALL. */
#define BM_USB_ENDPTn_EPSTALL (0x02U)      /*!< Bit mask for USB_ENDPTn_EPSTALL. */
#define BS_USB_ENDPTn_EPSTALL (1U)         /*!< Bit field size in bits for USB_ENDPTn_EPSTALL. */

/*! @brief Read current value of the USB_ENDPTn_EPSTALL field. */
#define BR_USB_ENDPTn_EPSTALL(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL, BS_USB_ENDPTn_EPSTALL))

/*! @brief Format value for bitfield USB_ENDPTn_EPSTALL. */
#define BF_USB_ENDPTn_EPSTALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL) & BM_USB_ENDPTn_EPSTALL)

/*! @brief Set the EPSTALL field to a new value. */
#define BW_USB_ENDPTn_EPSTALL(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL), BP_USB_ENDPTn_EPSTALL, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPTXEN (2U)          /*!< Bit position for USB_ENDPTn_EPTXEN. */
#define BM_USB_ENDPTn_EPTXEN (0x04U)       /*!< Bit mask for USB_ENDPTn_EPTXEN. */
#define BS_USB_ENDPTn_EPTXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPTXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPTXEN field. */
#define BR_USB_ENDPTn_EPTXEN(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN, BS_USB_ENDPTn_EPTXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPTXEN. */
#define BF_USB_ENDPTn_EPTXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN) & BM_USB_ENDPTn_EPTXEN)

/*! @brief Set the EPTXEN field to a new value. */
#define BW_USB_ENDPTn_EPTXEN(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN), BP_USB_ENDPTn_EPTXEN, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPRXEN (3U)          /*!< Bit position for USB_ENDPTn_EPRXEN. */
#define BM_USB_ENDPTn_EPRXEN (0x08U)       /*!< Bit mask for USB_ENDPTn_EPRXEN. */
#define BS_USB_ENDPTn_EPRXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPRXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPRXEN field. */
#define BR_USB_ENDPTn_EPRXEN(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN, BS_USB_ENDPTn_EPRXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPRXEN. */
#define BF_USB_ENDPTn_EPRXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN) & BM_USB_ENDPTn_EPRXEN)

/*! @brief Set the EPRXEN field to a new value. */
#define BW_USB_ENDPTn_EPRXEN(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN), BP_USB_ENDPTn_EPRXEN, 1))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set. See #aal353jj
 */
/*@{*/
#define BP_USB_ENDPTn_EPCTLDIS (4U)        /*!< Bit position for USB_ENDPTn_EPCTLDIS. */
#define BM_USB_ENDPTn_EPCTLDIS (0x10U)     /*!< Bit mask for USB_ENDPTn_EPCTLDIS. */
#define BS_USB_ENDPTn_EPCTLDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_EPCTLDIS. */

/*! @brief Read current value of the USB_ENDPTn_EPCTLDIS field. */
#define BR_USB_ENDPTn_EPCTLDIS(x, n) (BME_UBFX8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS, BS_USB_ENDPTn_EPCTLDIS))

/*! @brief Format value for bitfield USB_ENDPTn_EPCTLDIS. */
#define BF_USB_ENDPTn_EPCTLDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS) & BM_USB_ENDPTn_EPCTLDIS)

/*! @brief Set the EPCTLDIS field to a new value. */
#define BW_USB_ENDPTn_EPCTLDIS(x, n, v) (BME_BFI8(HW_USB_ENDPTn_ADDR(x, n), ((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS), BP_USB_ENDPTn_EPCTLDIS, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
typedef union _hw_usb_usbctrl
{
    uint8_t U;
    struct _hw_usb_usbctrl_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PDE : 1;               /*!< [6]  */
        uint8_t SUSP : 1;              /*!< [7]  */
    } B;
} hw_usb_usbctrl_t;

/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define HW_USB_USBCTRL_ADDR(x)   ((x) + 0x100U)

#define HW_USB_USBCTRL(x)        (*(__IO hw_usb_usbctrl_t *) HW_USB_USBCTRL_ADDR(x))
#define HW_USB_USBCTRL_RD(x)     (HW_USB_USBCTRL(x).U)
#define HW_USB_USBCTRL_WR(x, v)  (HW_USB_USBCTRL(x).U = (v))
#define HW_USB_USBCTRL_SET(x, v) (BME_OR8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBCTRL_CLR(x, v) (BME_AND8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBCTRL_TOG(x, v) (BME_XOR8(HW_USB_USBCTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-.
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
#define BP_USB_USBCTRL_PDE   (6U)          /*!< Bit position for USB_USBCTRL_PDE. */
#define BM_USB_USBCTRL_PDE   (0x40U)       /*!< Bit mask for USB_USBCTRL_PDE. */
#define BS_USB_USBCTRL_PDE   (1U)          /*!< Bit field size in bits for USB_USBCTRL_PDE. */

/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define BR_USB_USBCTRL_PDE(x) (BME_UBFX8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE, BS_USB_USBCTRL_PDE))

/*! @brief Format value for bitfield USB_USBCTRL_PDE. */
#define BF_USB_USBCTRL_PDE(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_PDE) & BM_USB_USBCTRL_PDE)

/*! @brief Set the PDE field to a new value. */
#define BW_USB_USBCTRL_PDE(x, v) (BME_BFI8(HW_USB_USBCTRL_ADDR(x), ((uint8_t)(v) << BP_USB_USBCTRL_PDE), BP_USB_USBCTRL_PDE, 1))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
#define BP_USB_USBCTRL_SUSP  (7U)          /*!< Bit position for USB_USBCTRL_SUSP. */
#define BM_USB_USBCTRL_SUSP  (0x80U)       /*!< Bit mask for USB_USBCTRL_SUSP. */
#define BS_USB_USBCTRL_SUSP  (1U)          /*!< Bit field size in bits for USB_USBCTRL_SUSP. */

/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define BR_USB_USBCTRL_SUSP(x) (BME_UBFX8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP, BS_USB_USBCTRL_SUSP))

/*! @brief Format value for bitfield USB_USBCTRL_SUSP. */
#define BF_USB_USBCTRL_SUSP(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_SUSP) & BM_USB_USBCTRL_SUSP)

/*! @brief Set the SUSP field to a new value. */
#define BW_USB_USBCTRL_SUSP(x, v) (BME_BFI8(HW_USB_USBCTRL_ADDR(x), ((uint8_t)(v) << BP_USB_USBCTRL_SUSP), BP_USB_USBCTRL_SUSP, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief HW_USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
typedef union _hw_usb_observe
{
    uint8_t U;
    struct _hw_usb_observe_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DMPD : 1;              /*!< [4]  */
        uint8_t RESERVED1 : 1;         /*!< [5]  */
        uint8_t DPPD : 1;              /*!< [6]  */
        uint8_t DPPU : 1;              /*!< [7]  */
    } B;
} hw_usb_observe_t;

/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define HW_USB_OBSERVE_ADDR(x)   ((x) + 0x104U)

#define HW_USB_OBSERVE(x)        (*(__I hw_usb_observe_t *) HW_USB_OBSERVE_ADDR(x))
#define HW_USB_OBSERVE_RD(x)     (HW_USB_OBSERVE(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown signal output from USB.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DMPD  (4U)          /*!< Bit position for USB_OBSERVE_DMPD. */
#define BM_USB_OBSERVE_DMPD  (0x10U)       /*!< Bit mask for USB_OBSERVE_DMPD. */
#define BS_USB_OBSERVE_DMPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DMPD. */

/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define BR_USB_OBSERVE_DMPD(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DMPD, BS_USB_OBSERVE_DMPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown signal output from USB.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPD  (6U)          /*!< Bit position for USB_OBSERVE_DPPD. */
#define BM_USB_OBSERVE_DPPD  (0x40U)       /*!< Bit mask for USB_OBSERVE_DPPD. */
#define BS_USB_OBSERVE_DPPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPD. */

/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define BR_USB_OBSERVE_DPPD(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPD, BS_USB_OBSERVE_DPPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup signal output from USB .
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPU  (7U)          /*!< Bit position for USB_OBSERVE_DPPU. */
#define BM_USB_OBSERVE_DPPU  (0x80U)       /*!< Bit mask for USB_OBSERVE_DPPU. */
#define BS_USB_OBSERVE_DPPU  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPU. */

/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define BR_USB_OBSERVE_DPPU(x) (BME_UBFX8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPU, BS_USB_OBSERVE_DPPU))
/*@}*/

/*******************************************************************************
 * HW_USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_control
{
    uint8_t U;
    struct _hw_usb_control_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DPPULLUPNONOTG : 1;    /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_control_t;

/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define HW_USB_CONTROL_ADDR(x)   ((x) + 0x108U)

#define HW_USB_CONTROL(x)        (*(__IO hw_usb_control_t *) HW_USB_CONTROL_ADDR(x))
#define HW_USB_CONTROL_RD(x)     (HW_USB_CONTROL(x).U)
#define HW_USB_CONTROL_WR(x, v)  (HW_USB_CONTROL(x).U = (v))
#define HW_USB_CONTROL_SET(x, v) (BME_OR8(HW_USB_CONTROL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CONTROL_CLR(x, v) (BME_AND8(HW_USB_CONTROL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CONTROL_TOG(x, v) (BME_XOR8(HW_USB_CONTROL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USB, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0 - DP Pullup in non-OTG device mode is not enabled.
 * - 1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
#define BP_USB_CONTROL_DPPULLUPNONOTG (4U) /*!< Bit position for USB_CONTROL_DPPULLUPNONOTG. */
#define BM_USB_CONTROL_DPPULLUPNONOTG (0x10U) /*!< Bit mask for USB_CONTROL_DPPULLUPNONOTG. */
#define BS_USB_CONTROL_DPPULLUPNONOTG (1U) /*!< Bit field size in bits for USB_CONTROL_DPPULLUPNONOTG. */

/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define BR_USB_CONTROL_DPPULLUPNONOTG(x) (BME_UBFX8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG, BS_USB_CONTROL_DPPULLUPNONOTG))

/*! @brief Format value for bitfield USB_CONTROL_DPPULLUPNONOTG. */
#define BF_USB_CONTROL_DPPULLUPNONOTG(v) ((uint8_t)((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG) & BM_USB_CONTROL_DPPULLUPNONOTG)

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define BW_USB_CONTROL_DPPULLUPNONOTG(x, v) (BME_BFI8(HW_USB_CONTROL_ADDR(x), ((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG), BP_USB_CONTROL_DPPULLUPNONOTG, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief HW_USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
typedef union _hw_usb_usbtrc0
{
    uint8_t U;
    struct _hw_usb_usbtrc0_bitfields
    {
        uint8_t USB_RESUME_INT : 1;    /*!< [0] USB Asynchronous Interrupt */
        uint8_t SYNC_DET : 1;          /*!< [1] Synchronous USB Interrupt Detect */
        uint8_t USB_CLK_RECOVERY_INT : 1; /*!< [2] Combined USB Clock
                                        * Recovery interrupt status */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t USBRESMEN : 1;         /*!< [5] Asynchronous Resume Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t USBRESET : 1;          /*!< [7] USB Reset */
    } B;
} hw_usb_usbtrc0_t;

/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define HW_USB_USBTRC0_ADDR(x)   ((x) + 0x10CU)

#define HW_USB_USBTRC0(x)        (*(__IO hw_usb_usbtrc0_t *) HW_USB_USBTRC0_ADDR(x))
#define HW_USB_USBTRC0_RD(x)     (HW_USB_USBTRC0(x).U)
#define HW_USB_USBTRC0_WR(x, v)  (HW_USB_USBTRC0(x).U = (v))
#define HW_USB_USBTRC0_SET(x, v) (BME_OR8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBTRC0_CLR(x, v) (BME_AND8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBTRC0_TOG(x, v) (BME_XOR8(HW_USB_USBTRC0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_RESUME_INT (0U) /*!< Bit position for USB_USBTRC0_USB_RESUME_INT. */
#define BM_USB_USBTRC0_USB_RESUME_INT (0x01U) /*!< Bit mask for USB_USBTRC0_USB_RESUME_INT. */
#define BS_USB_USBTRC0_USB_RESUME_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_RESUME_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define BR_USB_USBTRC0_USB_RESUME_INT(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_RESUME_INT, BS_USB_USBTRC0_USB_RESUME_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
#define BP_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit position for USB_USBTRC0_SYNC_DET. */
#define BM_USB_USBTRC0_SYNC_DET (0x02U)    /*!< Bit mask for USB_USBTRC0_SYNC_DET. */
#define BS_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit field size in bits for USB_USBTRC0_SYNC_DET. */

/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define BR_USB_USBTRC0_SYNC_DET(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_SYNC_DET, BS_USB_USBTRC0_SYNC_DET))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_CLK_RECOVERY_INT (2U) /*!< Bit position for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BM_USB_USBTRC0_USB_CLK_RECOVERY_INT (0x04U) /*!< Bit mask for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BS_USB_USBTRC0_USB_CLK_RECOVERY_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_CLK_RECOVERY_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define BR_USB_USBTRC0_USB_CLK_RECOVERY_INT(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_CLK_RECOVERY_INT, BS_USB_USBTRC0_USB_CLK_RECOVERY_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESMEN (5U)      /*!< Bit position for USB_USBTRC0_USBRESMEN. */
#define BM_USB_USBTRC0_USBRESMEN (0x20U)   /*!< Bit mask for USB_USBTRC0_USBRESMEN. */
#define BS_USB_USBTRC0_USBRESMEN (1U)      /*!< Bit field size in bits for USB_USBTRC0_USBRESMEN. */

/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define BR_USB_USBTRC0_USBRESMEN(x) (BME_UBFX8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN, BS_USB_USBTRC0_USBRESMEN))

/*! @brief Format value for bitfield USB_USBTRC0_USBRESMEN. */
#define BF_USB_USBTRC0_USBRESMEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN) & BM_USB_USBTRC0_USBRESMEN)

/*! @brief Set the USBRESMEN field to a new value. */
#define BW_USB_USBTRC0_USBRESMEN(x, v) (BME_BFI8(HW_USB_USBTRC0_ADDR(x), ((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN), BP_USB_USBTRC0_USBRESMEN, 1))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USB. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two USB
 * clock cycles after setting this bit.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESET (7U)       /*!< Bit position for USB_USBTRC0_USBRESET. */
#define BM_USB_USBTRC0_USBRESET (0x80U)    /*!< Bit mask for USB_USBTRC0_USBRESET. */
#define BS_USB_USBTRC0_USBRESET (1U)       /*!< Bit field size in bits for USB_USBTRC0_USBRESET. */

/*! @brief Format value for bitfield USB_USBTRC0_USBRESET. */
#define BF_USB_USBTRC0_USBRESET(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESET) & BM_USB_USBTRC0_USBRESET)
/*@}*/

/*******************************************************************************
 * HW_USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_usbfrmadjust
{
    uint8_t U;
    struct _hw_usb_usbfrmadjust_bitfields
    {
        uint8_t ADJ : 8;               /*!< [7:0] Frame Adjustment */
    } B;
} hw_usb_usbfrmadjust_t;

/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define HW_USB_USBFRMADJUST_ADDR(x) ((x) + 0x114U)

#define HW_USB_USBFRMADJUST(x)   (*(__IO hw_usb_usbfrmadjust_t *) HW_USB_USBFRMADJUST_ADDR(x))
#define HW_USB_USBFRMADJUST_RD(x) (HW_USB_USBFRMADJUST(x).U)
#define HW_USB_USBFRMADJUST_WR(x, v) (HW_USB_USBFRMADJUST(x).U = (v))
#define HW_USB_USBFRMADJUST_SET(x, v) (BME_OR8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(v)))
#define HW_USB_USBFRMADJUST_CLR(x, v) (BME_AND8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_USBFRMADJUST_TOG(x, v) (BME_XOR8(HW_USB_USBFRMADJUST_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBFRMADJUST bitfields
 */

/*!
 * @name Register USB_USBFRMADJUST, field ADJ[7:0] (RW)
 *
 * In Host mode, the frame adjustment is a twos complement number that adjusts
 * the period of each USB frame in 12-MHz clock periods. A SOF is normally
 * generated every 12,000 12-MHz clock cycles. The Frame Adjust Register can adjust this
 * by -128 to +127 to compensate for inaccuracies in the USB 48-MHz clock.
 * Changes to the ADJ bit take effect at the next start of the next frame.
 */
/*@{*/
#define BP_USB_USBFRMADJUST_ADJ (0U)       /*!< Bit position for USB_USBFRMADJUST_ADJ. */
#define BM_USB_USBFRMADJUST_ADJ (0xFFU)    /*!< Bit mask for USB_USBFRMADJUST_ADJ. */
#define BS_USB_USBFRMADJUST_ADJ (8U)       /*!< Bit field size in bits for USB_USBFRMADJUST_ADJ. */

/*! @brief Read current value of the USB_USBFRMADJUST_ADJ field. */
#define BR_USB_USBFRMADJUST_ADJ(x) (HW_USB_USBFRMADJUST(x).U)

/*! @brief Format value for bitfield USB_USBFRMADJUST_ADJ. */
#define BF_USB_USBFRMADJUST_ADJ(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBFRMADJUST_ADJ) & BM_USB_USBFRMADJUST_ADJ)

/*! @brief Set the ADJ field to a new value. */
#define BW_USB_USBFRMADJUST_ADJ(x, v) (HW_USB_USBFRMADJUST_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
typedef union _hw_usb_clk_recover_ctrl
{
    uint8_t U;
    struct _hw_usb_clk_recover_ctrl_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RESTART_IFRTRIM_EN : 1; /*!< [5] Restart from IFR trim value
                                        * */
        uint8_t RESET_RESUME_ROUGH_EN : 1; /*!< [6] Reset/resume to rough
                                        * phase enable */
        uint8_t CLOCK_RECOVER_EN : 1;  /*!< [7] Crystal-less USB enable */
    } B;
} hw_usb_clk_recover_ctrl_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_CTRL_ADDR(x) ((x) + 0x140U)

#define HW_USB_CLK_RECOVER_CTRL(x) (*(__IO hw_usb_clk_recover_ctrl_t *) HW_USB_CLK_RECOVER_CTRL_ADDR(x))
#define HW_USB_CLK_RECOVER_CTRL_RD(x) (HW_USB_CLK_RECOVER_CTRL(x).U)
#define HW_USB_CLK_RECOVER_CTRL_WR(x, v) (HW_USB_CLK_RECOVER_CTRL(x).U = (v))
#define HW_USB_CLK_RECOVER_CTRL_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_CTRL_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_CTRL_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (5U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (0x20U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN, BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) & BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN)

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN, 1))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (6U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (0x40U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN, BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) & BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN)

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN, 1))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0 - Disable clock recovery block (default)
 * - 1 - Enable clock recovery block
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (7U) /*!< Bit position for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (0x80U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN, BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BF_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) & BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN)

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
typedef union _hw_usb_clk_recover_irc_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_irc_en_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t IRC_EN : 1;            /*!< [1] IRC48M enable */
        uint8_t RESERVED1 : 6;         /*!< [7:2]  */
    } B;
} hw_usb_clk_recover_irc_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_IRC_EN_ADDR(x) ((x) + 0x144U)

#define HW_USB_CLK_RECOVER_IRC_EN(x) (*(__IO hw_usb_clk_recover_irc_en_t *) HW_USB_CLK_RECOVER_IRC_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_IRC_EN_RD(x) (HW_USB_CLK_RECOVER_IRC_EN(x).U)
#define HW_USB_CLK_RECOVER_IRC_EN_WR(x, v) (HW_USB_CLK_RECOVER_IRC_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_IRC_EN_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_IRC_EN_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_IRC_EN_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can be used for FS USB device mode operation. This bit
 * must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0 - Disable the IRC48M module (default)
 * - 1 - Enable the IRC48M module
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_IRC_EN (0x02U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_IRC_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_IRC_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN, BS_USB_CLK_RECOVER_IRC_EN_IRC_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_IRC_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) & BM_USB_CLK_RECOVER_IRC_EN_IRC_EN)

/*! @brief Set the IRC_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_IRC_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable (RW)
 *
 * Reset value: 0x10U
 *
 * Enables or masks the individual interrupt flags which are logically OR'ed
 * together to produce the combined interrupt indication on the USB_CLK_RECOVERY_INT
 * bit in the USB_USBTRC0 register if the indicated conditions have been
 * detected in the USB clock recovery algorithm operation.
 */
typedef union _hw_usb_clk_recover_int_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_en_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR_EN : 1;      /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_EN_ADDR(x) ((x) + 0x154U)

#define HW_USB_CLK_RECOVER_INT_EN(x) (*(__IO hw_usb_clk_recover_int_en_t *) HW_USB_CLK_RECOVER_INT_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_EN_RD(x) (HW_USB_CLK_RECOVER_INT_EN(x).U)
#define HW_USB_CLK_RECOVER_INT_EN_WR(x, v) (HW_USB_CLK_RECOVER_INT_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_EN_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_INT_EN_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_INT_EN_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_EN, field OVF_ERROR_EN[4] (RW)
 *
 * Determines whether OVF_ERROR condition signal is used in generation of
 * USB_CLK_RECOVERY_INT.
 *
 * Values:
 * - 0 - The interrupt will be masked
 * - 1 - The interrupt will be enabled (default)
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (4U) /*!< Bit position for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BM_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BS_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN field. */
#define BR_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(x) (BME_UBFX8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN, BS_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN. */
#define BF_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN) & BM_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN)

/*! @brief Set the OVF_ERROR_EN field to a new value. */
#define BW_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_INT_EN_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN), BP_USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN, 1))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
typedef union _hw_usb_clk_recover_int_status
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_status_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR : 1;         /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_status_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x) ((x) + 0x15CU)

#define HW_USB_CLK_RECOVER_INT_STATUS(x) (*(__IO hw_usb_clk_recover_int_status_t *) HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_STATUS_RD(x) (HW_USB_CLK_RECOVER_INT_STATUS(x).U)
#define HW_USB_CLK_RECOVER_INT_STATUS_WR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_STATUS_SET(x, v) (BME_OR8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_CLR(x, v) (BME_AND8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(~(v))))
#define HW_USB_CLK_RECOVER_INT_STATUS_TOG(x, v) (BME_XOR8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0 - No interrupt is reported
 * - 1 - Unmasked interrupt has been generated
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (4U) /*!< Bit position for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define BR_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x) (BME_UBFX8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR, BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BF_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) & BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR)

/*! @brief Set the OVF_ERROR field to a new value. */
#define BW_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x, v) (BME_BFI8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), ((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR, 1))
/*@}*/

/*******************************************************************************
 * hw_usb_t - module struct
 ******************************************************************************/
/*!
 * @brief All USB module registers.
 */
#pragma pack(1)
typedef struct _hw_usb
{
    __I hw_usb_perid_t PERID;              /*!< [0x0] Peripheral ID register */
    uint8_t _reserved0[3];
    __I hw_usb_idcomp_t IDCOMP;            /*!< [0x4] Peripheral ID Complement register */
    uint8_t _reserved1[3];
    __I hw_usb_rev_t REV;                  /*!< [0x8] Peripheral Revision register */
    uint8_t _reserved2[3];
    __I hw_usb_addinfo_t ADDINFO;          /*!< [0xC] Peripheral Additional Info register */
    uint8_t _reserved3[15];
    __IO hw_usb_otgctl_t OTGCTL;           /*!< [0x1C] OTG Control register */
    uint8_t _reserved4[99];
    __IO hw_usb_istat_t ISTAT;             /*!< [0x80] Interrupt Status register */
    uint8_t _reserved5[3];
    __IO hw_usb_inten_t INTEN;             /*!< [0x84] Interrupt Enable register */
    uint8_t _reserved6[3];
    __IO hw_usb_errstat_t ERRSTAT;         /*!< [0x88] Error Interrupt Status register */
    uint8_t _reserved7[3];
    __IO hw_usb_erren_t ERREN;             /*!< [0x8C] Error Interrupt Enable register */
    uint8_t _reserved8[3];
    __I hw_usb_stat_t STAT;                /*!< [0x90] Status register */
    uint8_t _reserved9[3];
    __IO hw_usb_ctl_t CTL;                 /*!< [0x94] Control register */
    uint8_t _reserved10[3];
    __IO hw_usb_addr_t ADDR;               /*!< [0x98] Address register */
    uint8_t _reserved11[3];
    __IO hw_usb_bdtpage1_t BDTPAGE1;       /*!< [0x9C] BDT Page register 1 */
    uint8_t _reserved12[3];
    __IO hw_usb_frmnuml_t FRMNUML;         /*!< [0xA0] Frame Number register Low */
    uint8_t _reserved13[3];
    __IO hw_usb_frmnumh_t FRMNUMH;         /*!< [0xA4] Frame Number register High */
    uint8_t _reserved14[11];
    __IO hw_usb_bdtpage2_t BDTPAGE2;       /*!< [0xB0] BDT Page Register 2 */
    uint8_t _reserved15[3];
    __IO hw_usb_bdtpage3_t BDTPAGE3;       /*!< [0xB4] BDT Page Register 3 */
    uint8_t _reserved16[11];
    struct {
        __IO hw_usb_endptn_t ENDPTn;       /*!< [0xC0] Endpoint Control register */
        uint8_t _reserved0[3];
    } ENDPOINT[16];
    __IO hw_usb_usbctrl_t USBCTRL;         /*!< [0x100] USB Control register */
    uint8_t _reserved17[3];
    __I hw_usb_observe_t OBSERVE;          /*!< [0x104] USB OTG Observe register */
    uint8_t _reserved18[3];
    __IO hw_usb_control_t CONTROL;         /*!< [0x108] USB OTG Control register */
    uint8_t _reserved19[3];
    __IO hw_usb_usbtrc0_t USBTRC0;         /*!< [0x10C] USB Transceiver Control register 0 */
    uint8_t _reserved20[7];
    __IO hw_usb_usbfrmadjust_t USBFRMADJUST; /*!< [0x114] Frame Adjust Register */
    uint8_t _reserved21[43];
    __IO hw_usb_clk_recover_ctrl_t CLK_RECOVER_CTRL; /*!< [0x140] USB Clock recovery control */
    uint8_t _reserved22[3];
    __IO hw_usb_clk_recover_irc_en_t CLK_RECOVER_IRC_EN; /*!< [0x144] IRC48M oscillator enable register */
    uint8_t _reserved23[15];
    __IO hw_usb_clk_recover_int_en_t CLK_RECOVER_INT_EN; /*!< [0x154] Clock recovery combined interrupt enable */
    uint8_t _reserved24[7];
    __IO hw_usb_clk_recover_int_status_t CLK_RECOVER_INT_STATUS; /*!< [0x15C] Clock recovery separated interrupt status */
} hw_usb_t;
#pragma pack()

/*! @brief Macro to access all USB registers. */
/*! @param x USB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_USB(USB0_BASE)</code>. */
#define HW_USB(x)      (*(hw_usb_t *)(x))

#endif /* __HW_USB_REGISTERS_H__ */
/* EOF */
