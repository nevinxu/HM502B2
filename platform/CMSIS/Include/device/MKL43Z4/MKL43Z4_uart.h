/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KL43P64M48SF6RM, Rev.3, Aug 2014
**     Version:             rev. 1.3, 2014-08-21
**     Build:               b140821
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-03-27)
**         Initial version.
**     - rev. 1.1 (2014-05-26)
**         I2S registers TCR2/RCR2 and others were changed.
**         FLEXIO register FLEXIO_VERID has now bitfields: FEATURE, MINOR, MAJOR.
**         Names of the bitfields of the FLEXIO_SHIFTBUF have been changed to the appropriate register name e.g.: FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS.
**         Peripheral_BASES macros has been changed to Peripheral_BASE_PTRS, e.g.: ADC_BASES to ADC_BASE_PTRS.
**         Clock configuration for high range external oscillator has been added.
**         RFSYS module access has been added.
**     - rev. 1.2 (2014-07-10)
**         GPIO - Renamed modules PTA,PTB,PTC,PTD,PTE to GPIOA,GPIOB,GPIOC,GPIOD,GPIOE.
**         UART0 - UART0 module renamed to UART2.
**         I2S - removed MDR register.
**     - rev. 1.3 (2014-08-21)
**         UART2 - Removed ED register.
**         UART2 - Removed MODEM register.
**         UART2 - Removed IR register.
**         UART2 - Removed PFIFO register.
**         UART2 - Removed CFIFO register.
**         UART2 - Removed SFIFO register.
**         UART2 - Removed TWFIFO register.
**         UART2 - Removed TCFIFO register.
**         UART2 - Removed RWFIFO register.
**         UART2 - Removed RCFIFO register.
**         USB - Removed bitfield REG_EN in CLK_RECOVER_IRC_EN register.
**         SIM - Changed bitfield value MCGIRCLK to LIRC_CLK of bitfield CLKOUTSEL in SOPT2 register.
**         SIM - Removed bitfield DIEID in SDID register.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_UART_REGISTERS_H__
#define __HW_UART_REGISTERS_H__

#include "MKL43Z4.h"
#include "fsl_bitaccess.h"

/*
 * MKL43Z4 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - HW_UART_BDH - UART Baud Rate Registers: High
 * - HW_UART_BDL - UART Baud Rate Registers: Low
 * - HW_UART_C1 - UART Control Register 1
 * - HW_UART_C2 - UART Control Register 2
 * - HW_UART_S1 - UART Status Register 1
 * - HW_UART_S2 - UART Status Register 2
 * - HW_UART_C3 - UART Control Register 3
 * - HW_UART_D - UART Data Register
 * - HW_UART_MA1 - UART Match Address Registers 1
 * - HW_UART_MA2 - UART Match Address Registers 2
 * - HW_UART_C4 - UART Control Register 4
 * - HW_UART_C5 - UART Control Register 5
 * - HW_UART_C7816 - UART 7816 Control Register
 * - HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 * - HW_UART_IS7816 - UART 7816 Interrupt Status Register
 * - HW_UART_WP7816 - UART 7816 Wait Parameter Register
 * - HW_UART_WN7816 - UART 7816 Wait N Register
 * - HW_UART_WF7816 - UART 7816 Wait FD Register
 * - HW_UART_ET7816 - UART 7816 Error Threshold Register
 * - HW_UART_TL7816 - UART 7816 Transmit Length Register
 * - HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 * - HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 * - HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 * - HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 * - HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 * - HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 * - HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 * - HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 *
 * - hw_uart_t - Struct containing all module registers.
 */

#define HW_UART_INSTANCE_COUNT (1U) /*!< Number of instances of the UART module. */
#define HW_UART2 (0U) /*!< Instance number for UART2. */

/*******************************************************************************
 * HW_UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief HW_UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdh
{
    uint8_t U;
    struct _hw_uart_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] UART Baud Rate Bits */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RXEDGIE : 1;           /*!< [6] RxD Input Active Edge Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [7] Reserved. */
    } B;
} hw_uart_bdh_t;

/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define HW_UART_BDH_ADDR(x)      ((x) + 0x0U)

#define HW_UART_BDH(x)           (*(__IO hw_uart_bdh_t *) HW_UART_BDH_ADDR(x))
#define HW_UART_BDH_RD(x)        (HW_UART_BDH(x).U)
#define HW_UART_BDH_WR(x, v)     (HW_UART_BDH(x).U = (v))
#define HW_UART_BDH_SET(x, v)    (BME_OR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDH_CLR(x, v)    (BME_AND8(HW_UART_BDH_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDH_TOG(x, v)    (BME_XOR8(HW_UART_BDH_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
#define BP_UART_BDH_SBR      (0U)          /*!< Bit position for UART_BDH_SBR. */
#define BM_UART_BDH_SBR      (0x1FU)       /*!< Bit mask for UART_BDH_SBR. */
#define BS_UART_BDH_SBR      (5U)          /*!< Bit field size in bits for UART_BDH_SBR. */

/*! @brief Read current value of the UART_BDH_SBR field. */
#define BR_UART_BDH_SBR(x)   (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBR, BS_UART_BDH_SBR))

/*! @brief Format value for bitfield UART_BDH_SBR. */
#define BF_UART_BDH_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBR) & BM_UART_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDH_SBR(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_SBR), BP_UART_BDH_SBR, 5))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
#define BP_UART_BDH_RXEDGIE  (6U)          /*!< Bit position for UART_BDH_RXEDGIE. */
#define BM_UART_BDH_RXEDGIE  (0x40U)       /*!< Bit mask for UART_BDH_RXEDGIE. */
#define BS_UART_BDH_RXEDGIE  (1U)          /*!< Bit field size in bits for UART_BDH_RXEDGIE. */

/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define BR_UART_BDH_RXEDGIE(x) (BME_UBFX8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE, BS_UART_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART_BDH_RXEDGIE. */
#define BF_UART_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_RXEDGIE) & BM_UART_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART_BDH_RXEDGIE(x, v) (BME_BFI8(HW_UART_BDH_ADDR(x), ((uint8_t)(v) << BP_UART_BDH_RXEDGIE), BP_UART_BDH_RXEDGIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief HW_UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdl
{
    uint8_t U;
    struct _hw_uart_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] UART Baud Rate Bits */
    } B;
} hw_uart_bdl_t;

/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define HW_UART_BDL_ADDR(x)      ((x) + 0x1U)

#define HW_UART_BDL(x)           (*(__IO hw_uart_bdl_t *) HW_UART_BDL_ADDR(x))
#define HW_UART_BDL_RD(x)        (HW_UART_BDL(x).U)
#define HW_UART_BDL_WR(x, v)     (HW_UART_BDL(x).U = (v))
#define HW_UART_BDL_SET(x, v)    (BME_OR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
#define HW_UART_BDL_CLR(x, v)    (BME_AND8(HW_UART_BDL_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_BDL_TOG(x, v)    (BME_XOR8(HW_UART_BDL_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDL bitfields
 */

/*!
 * @name Register UART_BDL, field SBR[7:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
#define BP_UART_BDL_SBR      (0U)          /*!< Bit position for UART_BDL_SBR. */
#define BM_UART_BDL_SBR      (0xFFU)       /*!< Bit mask for UART_BDL_SBR. */
#define BS_UART_BDL_SBR      (8U)          /*!< Bit field size in bits for UART_BDL_SBR. */

/*! @brief Read current value of the UART_BDL_SBR field. */
#define BR_UART_BDL_SBR(x)   (HW_UART_BDL(x).U)

/*! @brief Format value for bitfield UART_BDL_SBR. */
#define BF_UART_BDL_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDL_SBR) & BM_UART_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDL_SBR(x, v) (HW_UART_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
typedef union _hw_uart_c1
{
    uint8_t U;
    struct _hw_uart_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-bit or 8-bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t RESERVED0 : 1;         /*!< [6] Reserved. */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart_c1_t;

/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define HW_UART_C1_ADDR(x)       ((x) + 0x2U)

#define HW_UART_C1(x)            (*(__IO hw_uart_c1_t *) HW_UART_C1_ADDR(x))
#define HW_UART_C1_RD(x)         (HW_UART_C1(x).U)
#define HW_UART_C1_WR(x, v)      (HW_UART_C1(x).U = (v))
#define HW_UART_C1_SET(x, v)     (BME_OR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
#define HW_UART_C1_CLR(x, v)     (BME_AND8(HW_UART_C1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C1_TOG(x, v)     (BME_XOR8(HW_UART_C1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART_C1_PT        (0U)          /*!< Bit position for UART_C1_PT. */
#define BM_UART_C1_PT        (0x01U)       /*!< Bit mask for UART_C1_PT. */
#define BS_UART_C1_PT        (1U)          /*!< Bit field size in bits for UART_C1_PT. */

/*! @brief Read current value of the UART_C1_PT field. */
#define BR_UART_C1_PT(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PT, BS_UART_C1_PT))

/*! @brief Format value for bitfield UART_C1_PT. */
#define BF_UART_C1_PT(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PT) & BM_UART_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART_C1_PT(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PT), BP_UART_C1_PT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
#define BP_UART_C1_PE        (1U)          /*!< Bit position for UART_C1_PE. */
#define BM_UART_C1_PE        (0x02U)       /*!< Bit mask for UART_C1_PE. */
#define BS_UART_C1_PE        (1U)          /*!< Bit field size in bits for UART_C1_PE. */

/*! @brief Read current value of the UART_C1_PE field. */
#define BR_UART_C1_PE(x)     (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_PE, BS_UART_C1_PE))

/*! @brief Format value for bitfield UART_C1_PE. */
#define BF_UART_C1_PE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PE) & BM_UART_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART_C1_PE(x, v)  (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_PE), BP_UART_C1_PE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART_C1_ILT       (2U)          /*!< Bit position for UART_C1_ILT. */
#define BM_UART_C1_ILT       (0x04U)       /*!< Bit mask for UART_C1_ILT. */
#define BS_UART_C1_ILT       (1U)          /*!< Bit field size in bits for UART_C1_ILT. */

/*! @brief Read current value of the UART_C1_ILT field. */
#define BR_UART_C1_ILT(x)    (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT, BS_UART_C1_ILT))

/*! @brief Format value for bitfield UART_C1_ILT. */
#define BF_UART_C1_ILT(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C1_ILT) & BM_UART_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART_C1_ILT(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_ILT), BP_UART_C1_ILT, 1))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle line wakeup.
 * - 1 - Address mark wakeup.
 */
/*@{*/
#define BP_UART_C1_WAKE      (3U)          /*!< Bit position for UART_C1_WAKE. */
#define BM_UART_C1_WAKE      (0x08U)       /*!< Bit mask for UART_C1_WAKE. */
#define BS_UART_C1_WAKE      (1U)          /*!< Bit field size in bits for UART_C1_WAKE. */

/*! @brief Read current value of the UART_C1_WAKE field. */
#define BR_UART_C1_WAKE(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE, BS_UART_C1_WAKE))

/*! @brief Format value for bitfield UART_C1_WAKE. */
#define BF_UART_C1_WAKE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_WAKE) & BM_UART_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART_C1_WAKE(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_WAKE), BP_UART_C1_WAKE, 1))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
 * - 1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
#define BP_UART_C1_M         (4U)          /*!< Bit position for UART_C1_M. */
#define BM_UART_C1_M         (0x10U)       /*!< Bit mask for UART_C1_M. */
#define BS_UART_C1_M         (1U)          /*!< Bit field size in bits for UART_C1_M. */

/*! @brief Read current value of the UART_C1_M field. */
#define BR_UART_C1_M(x)      (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_M, BS_UART_C1_M))

/*! @brief Format value for bitfield UART_C1_M. */
#define BF_UART_C1_M(v)      ((uint8_t)((uint8_t)(v) << BP_UART_C1_M) & BM_UART_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART_C1_M(x, v)   (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_M), BP_UART_C1_M, 1))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
#define BP_UART_C1_RSRC      (5U)          /*!< Bit position for UART_C1_RSRC. */
#define BM_UART_C1_RSRC      (0x20U)       /*!< Bit mask for UART_C1_RSRC. */
#define BS_UART_C1_RSRC      (1U)          /*!< Bit field size in bits for UART_C1_RSRC. */

/*! @brief Read current value of the UART_C1_RSRC field. */
#define BR_UART_C1_RSRC(x)   (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC, BS_UART_C1_RSRC))

/*! @brief Format value for bitfield UART_C1_RSRC. */
#define BF_UART_C1_RSRC(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_RSRC) & BM_UART_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART_C1_RSRC(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_RSRC), BP_UART_C1_RSRC, 1))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by RSRC.
 */
/*@{*/
#define BP_UART_C1_LOOPS     (7U)          /*!< Bit position for UART_C1_LOOPS. */
#define BM_UART_C1_LOOPS     (0x80U)       /*!< Bit mask for UART_C1_LOOPS. */
#define BS_UART_C1_LOOPS     (1U)          /*!< Bit field size in bits for UART_C1_LOOPS. */

/*! @brief Read current value of the UART_C1_LOOPS field. */
#define BR_UART_C1_LOOPS(x)  (BME_UBFX8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS, BS_UART_C1_LOOPS))

/*! @brief Format value for bitfield UART_C1_LOOPS. */
#define BF_UART_C1_LOOPS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C1_LOOPS) & BM_UART_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART_C1_LOOPS(x, v) (BME_BFI8(HW_UART_C1_ADDR(x), ((uint8_t)(v) << BP_UART_C1_LOOPS), BP_UART_C1_LOOPS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart_c2
{
    uint8_t U;
    struct _hw_uart_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt Enable */
        uint8_t RIE : 1;               /*!< [5] Receiver Full Interrupt or DMA Transfer
                                        * Enable */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt Enable */
        uint8_t TIE : 1;               /*!< [7] Transmitter Interrupt or DMA Transfer
                                        * Enable. */
    } B;
} hw_uart_c2_t;

/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define HW_UART_C2_ADDR(x)       ((x) + 0x3U)

#define HW_UART_C2(x)            (*(__IO hw_uart_c2_t *) HW_UART_C2_ADDR(x))
#define HW_UART_C2_RD(x)         (HW_UART_C2(x).U)
#define HW_UART_C2_WR(x, v)      (HW_UART_C2(x).U = (v))
#define HW_UART_C2_SET(x, v)     (BME_OR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
#define HW_UART_C2_CLR(x, v)     (BME_AND8(HW_UART_C2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C2_TOG(x, v)     (BME_XOR8(HW_UART_C2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set. This field
 * must be cleared when C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break characters to be sent.
 */
/*@{*/
#define BP_UART_C2_SBK       (0U)          /*!< Bit position for UART_C2_SBK. */
#define BM_UART_C2_SBK       (0x01U)       /*!< Bit mask for UART_C2_SBK. */
#define BS_UART_C2_SBK       (1U)          /*!< Bit field size in bits for UART_C2_SBK. */

/*! @brief Read current value of the UART_C2_SBK field. */
#define BR_UART_C2_SBK(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK, BS_UART_C2_SBK))

/*! @brief Format value for bitfield UART_C2_SBK. */
#define BF_UART_C2_SBK(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_SBK) & BM_UART_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART_C2_SBK(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_SBK), BP_UART_C2_SBK, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received after an IDLE is detected before IDLE is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
#define BP_UART_C2_RWU       (1U)          /*!< Bit position for UART_C2_RWU. */
#define BM_UART_C2_RWU       (0x02U)       /*!< Bit mask for UART_C2_RWU. */
#define BS_UART_C2_RWU       (1U)          /*!< Bit field size in bits for UART_C2_RWU. */

/*! @brief Read current value of the UART_C2_RWU field. */
#define BR_UART_C2_RWU(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU, BS_UART_C2_RWU))

/*! @brief Format value for bitfield UART_C2_RWU. */
#define BF_UART_C2_RWU(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RWU) & BM_UART_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART_C2_RWU(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RWU), BP_UART_C2_RWU, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
#define BP_UART_C2_RE        (2U)          /*!< Bit position for UART_C2_RE. */
#define BM_UART_C2_RE        (0x04U)       /*!< Bit mask for UART_C2_RE. */
#define BS_UART_C2_RE        (1U)          /*!< Bit field size in bits for UART_C2_RE. */

/*! @brief Read current value of the UART_C2_RE field. */
#define BR_UART_C2_RE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RE, BS_UART_C2_RE))

/*! @brief Format value for bitfield UART_C2_RE. */
#define BF_UART_C2_RE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_RE) & BM_UART_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART_C2_RE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RE), BP_UART_C2_RE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
#define BP_UART_C2_TE        (3U)          /*!< Bit position for UART_C2_TE. */
#define BM_UART_C2_TE        (0x08U)       /*!< Bit mask for UART_C2_TE. */
#define BS_UART_C2_TE        (1U)          /*!< Bit field size in bits for UART_C2_TE. */

/*! @brief Read current value of the UART_C2_TE field. */
#define BR_UART_C2_TE(x)     (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TE, BS_UART_C2_TE))

/*! @brief Format value for bitfield UART_C2_TE. */
#define BF_UART_C2_TE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_TE) & BM_UART_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART_C2_TE(x, v)  (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TE), BP_UART_C2_TE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requests
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_ILIE      (4U)          /*!< Bit position for UART_C2_ILIE. */
#define BM_UART_C2_ILIE      (0x10U)       /*!< Bit mask for UART_C2_ILIE. */
#define BS_UART_C2_ILIE      (1U)          /*!< Bit field size in bits for UART_C2_ILIE. */

/*! @brief Read current value of the UART_C2_ILIE field. */
#define BR_UART_C2_ILIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE, BS_UART_C2_ILIE))

/*! @brief Format value for bitfield UART_C2_ILIE. */
#define BF_UART_C2_ILIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_ILIE) & BM_UART_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART_C2_ILIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_ILIE), BP_UART_C2_ILIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_RIE       (5U)          /*!< Bit position for UART_C2_RIE. */
#define BM_UART_C2_RIE       (0x20U)       /*!< Bit mask for UART_C2_RIE. */
#define BS_UART_C2_RIE       (1U)          /*!< Bit field size in bits for UART_C2_RIE. */

/*! @brief Read current value of the UART_C2_RIE field. */
#define BR_UART_C2_RIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE, BS_UART_C2_RIE))

/*! @brief Format value for bitfield UART_C2_RIE. */
#define BF_UART_C2_RIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RIE) & BM_UART_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART_C2_RIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_RIE), BP_UART_C2_RIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
#define BP_UART_C2_TCIE      (6U)          /*!< Bit position for UART_C2_TCIE. */
#define BM_UART_C2_TCIE      (0x40U)       /*!< Bit mask for UART_C2_TCIE. */
#define BS_UART_C2_TCIE      (1U)          /*!< Bit field size in bits for UART_C2_TCIE. */

/*! @brief Read current value of the UART_C2_TCIE field. */
#define BR_UART_C2_TCIE(x)   (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE, BS_UART_C2_TCIE))

/*! @brief Format value for bitfield UART_C2_TCIE. */
#define BF_UART_C2_TCIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_TCIE) & BM_UART_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART_C2_TCIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TCIE), BP_UART_C2_TCIE, 1))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_TIE       (7U)          /*!< Bit position for UART_C2_TIE. */
#define BM_UART_C2_TIE       (0x80U)       /*!< Bit mask for UART_C2_TIE. */
#define BS_UART_C2_TIE       (1U)          /*!< Bit field size in bits for UART_C2_TIE. */

/*! @brief Read current value of the UART_C2_TIE field. */
#define BR_UART_C2_TIE(x)    (BME_UBFX8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE, BS_UART_C2_TIE))

/*! @brief Format value for bitfield UART_C2_TIE. */
#define BF_UART_C2_TIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_TIE) & BM_UART_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART_C2_TIE(x, v) (BME_BFI8(HW_UART_C2_ADDR(x), ((uint8_t)(v) << BP_UART_C2_TIE), BP_UART_C2_TIE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
typedef union _hw_uart_s1
{
    uint8_t U;
    struct _hw_uart_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmit Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart_s1_t;

/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define HW_UART_S1_ADDR(x)       ((x) + 0x4U)

#define HW_UART_S1(x)            (*(__I hw_uart_s1_t *) HW_UART_S1_ADDR(x))
#define HW_UART_S1_RD(x)         (HW_UART_S1(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D.
 *
 * Values:
 * - 0 - No parity error detected since the last time this flag was cleared. If
 *     the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
#define BP_UART_S1_PF        (0U)          /*!< Bit position for UART_S1_PF. */
#define BM_UART_S1_PF        (0x01U)       /*!< Bit mask for UART_S1_PF. */
#define BS_UART_S1_PF        (1U)          /*!< Bit field size in bits for UART_S1_PF. */

/*! @brief Read current value of the UART_S1_PF field. */
#define BR_UART_S1_PF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_PF, BS_UART_S1_PF))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. FE does not set in the
 * case of an overrun. FE inhibits further data reception until it is cleared. To
 * clear FE, read S1 with FE set and then read D. The last data in the receive
 * buffer represents the data that was received with the frame error enabled.
 * Framing errors are not supported when 7816E is set/enabled. However, if this flag
 * is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART_S1_FE        (1U)          /*!< Bit position for UART_S1_FE. */
#define BM_UART_S1_FE        (0x02U)       /*!< Bit mask for UART_S1_FE. */
#define BS_UART_S1_FE        (1U)          /*!< Bit field size in bits for UART_S1_FE. */

/*! @brief Read current value of the UART_S1_FE field. */
#define BR_UART_S1_FE(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_FE, BS_UART_S1_FE))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun. When NF is set, it indicates only that a
 * dataword has been received with noise since the last time it was cleared. There
 * is no guarantee that the first dataword read from the receive buffer has noise
 * or that there is only one dataword in the buffer that was received with noise
 * unless the receive buffer has a depth of one. To clear NF, read S1 and then
 * read D.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
#define BP_UART_S1_NF        (2U)          /*!< Bit position for UART_S1_NF. */
#define BM_UART_S1_NF        (0x04U)       /*!< Bit mask for UART_S1_NF. */
#define BS_UART_S1_NF        (1U)          /*!< Bit field size in bits for UART_S1_NF. */

/*! @brief Read current value of the UART_S1_NF field. */
#define BR_UART_S1_NF(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_NF, BS_UART_S1_NF))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit. In
 * 7816 mode, it is possible to configure a NACK to be returned by programing
 * C7816[ONACK].
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
#define BP_UART_S1_OR        (3U)          /*!< Bit position for UART_S1_OR. */
#define BM_UART_S1_OR        (0x08U)       /*!< Bit mask for UART_S1_OR. */
#define BS_UART_S1_OR        (1U)          /*!< Bit field size in bits for UART_S1_OR. */

/*! @brief Read current value of the UART_S1_OR field. */
#define BR_UART_S1_OR(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_OR, BS_UART_S1_OR))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set). To clear
 * IDLE, read UART status S1 with IDLE set and then read D. IDLE is set when either
 * of the following appear on the receiver input: 10 consecutive logic 1s if C1[M]
 * = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10] = 0 12 consecutive logic
 * 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle detection is not supported
 * when 7816E is set/enabled and hence this flag is ignored. When RWU is set and
 * WAKE is cleared, an idle line condition sets the IDLE flag if RWUID is set,
 * else the IDLE flag does not become set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
#define BP_UART_S1_IDLE      (4U)          /*!< Bit position for UART_S1_IDLE. */
#define BM_UART_S1_IDLE      (0x10U)       /*!< Bit mask for UART_S1_IDLE. */
#define BS_UART_S1_IDLE      (1U)          /*!< Bit field size in bits for UART_S1_IDLE. */

/*! @brief Read current value of the UART_S1_IDLE field. */
#define BR_UART_S1_IDLE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_IDLE, BS_UART_S1_IDLE))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
#define BP_UART_S1_RDRF      (5U)          /*!< Bit position for UART_S1_RDRF. */
#define BM_UART_S1_RDRF      (0x20U)       /*!< Bit mask for UART_S1_RDRF. */
#define BS_UART_S1_RDRF      (1U)          /*!< Bit field size in bits for UART_S1_RDRF. */

/*! @brief Read current value of the UART_S1_RDRF field. */
#define BR_UART_S1_RDRF(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_RDRF, BS_UART_S1_RDRF))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART_S1_TC        (6U)          /*!< Bit position for UART_S1_TC. */
#define BM_UART_S1_TC        (0x40U)       /*!< Bit mask for UART_S1_TC. */
#define BS_UART_S1_TC        (1U)          /*!< Bit field size in bits for UART_S1_TC. */

/*! @brief Read current value of the UART_S1_TC field. */
#define BR_UART_S1_TC(x)     (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TC, BS_UART_S1_TC))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
#define BP_UART_S1_TDRE      (7U)          /*!< Bit position for UART_S1_TDRE. */
#define BM_UART_S1_TDRE      (0x80U)       /*!< Bit mask for UART_S1_TDRE. */
#define BS_UART_S1_TDRE      (1U)          /*!< Bit field size in bits for UART_S1_TDRE. */

/*! @brief Read current value of the UART_S1_TDRE field. */
#define BR_UART_S1_TDRE(x)   (BME_UBFX8(HW_UART_S1_ADDR(x), BP_UART_S1_TDRE, BS_UART_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
typedef union _hw_uart_s2
{
    uint8_t U;
    struct _hw_uart_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t RESERVED0 : 1;         /*!< [1] Reserved. */
        uint8_t BRK13 : 1;             /*!< [2] Break Transmit Character Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wakeup Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t MSBF : 1;              /*!< [5] Most Significant Bit First */
        uint8_t RXEDGIF : 1;           /*!< [6] RxD Pin Active Edge Interrupt Flag */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_uart_s2_t;

/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define HW_UART_S2_ADDR(x)       ((x) + 0x5U)

#define HW_UART_S2(x)            (*(__IO hw_uart_s2_t *) HW_UART_S2_ADDR(x))
#define HW_UART_S2_RD(x)         (HW_UART_S2(x).U)
#define HW_UART_S2_WR(x, v)      (HW_UART_S2(x).U = (v))
#define HW_UART_S2_SET(x, v)     (BME_OR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
#define HW_UART_S2_CLR(x, v)     (BME_AND8(HW_UART_S2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_S2_TOG(x, v)     (BME_XOR8(HW_UART_S2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active, RxD input not idle.
 */
/*@{*/
#define BP_UART_S2_RAF       (0U)          /*!< Bit position for UART_S2_RAF. */
#define BM_UART_S2_RAF       (0x01U)       /*!< Bit mask for UART_S2_RAF. */
#define BS_UART_S2_RAF       (1U)          /*!< Bit field size in bits for UART_S2_RAF. */

/*! @brief Read current value of the UART_S2_RAF field. */
#define BR_UART_S2_RAF(x)    (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RAF, BS_UART_S2_RAF))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
#define BP_UART_S2_BRK13     (2U)          /*!< Bit position for UART_S2_BRK13. */
#define BM_UART_S2_BRK13     (0x04U)       /*!< Bit mask for UART_S2_BRK13. */
#define BS_UART_S2_BRK13     (1U)          /*!< Bit field size in bits for UART_S2_BRK13. */

/*! @brief Read current value of the UART_S2_BRK13 field. */
#define BR_UART_S2_BRK13(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13, BS_UART_S2_BRK13))

/*! @brief Format value for bitfield UART_S2_BRK13. */
#define BF_UART_S2_BRK13(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_BRK13) & BM_UART_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART_S2_BRK13(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_BRK13), BP_UART_S2_BRK13, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - S1[IDLE] is not set upon detection of an idle character.
 * - 1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
#define BP_UART_S2_RWUID     (3U)          /*!< Bit position for UART_S2_RWUID. */
#define BM_UART_S2_RWUID     (0x08U)       /*!< Bit mask for UART_S2_RWUID. */
#define BS_UART_S2_RWUID     (1U)          /*!< Bit field size in bits for UART_S2_RWUID. */

/*! @brief Read current value of the UART_S2_RWUID field. */
#define BR_UART_S2_RWUID(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID, BS_UART_S2_RWUID))

/*! @brief Format value for bitfield UART_S2_RWUID. */
#define BF_UART_S2_RWUID(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RWUID) & BM_UART_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART_S2_RWUID(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RWUID), BP_UART_S2_RWUID, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an initial
 * character is detected in T = 0 protocol mode. Setting RXINV inverts the RxD
 * input for data bits, start and stop bits, break, and idle. When C7816[ISO7816E] is
 * set/enabled, only the data bits and the parity bit are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
#define BP_UART_S2_RXINV     (4U)          /*!< Bit position for UART_S2_RXINV. */
#define BM_UART_S2_RXINV     (0x10U)       /*!< Bit mask for UART_S2_RXINV. */
#define BS_UART_S2_RXINV     (1U)          /*!< Bit field size in bits for UART_S2_RXINV. */

/*! @brief Read current value of the UART_S2_RXINV field. */
#define BR_UART_S2_RXINV(x)  (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV, BS_UART_S2_RXINV))

/*! @brief Format value for bitfield UART_S2_RXINV. */
#define BF_UART_S2_RXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXINV) & BM_UART_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART_S2_RXINV(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXINV), BP_UART_S2_RXINV, 1))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit, depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
#define BP_UART_S2_MSBF      (5U)          /*!< Bit position for UART_S2_MSBF. */
#define BM_UART_S2_MSBF      (0x20U)       /*!< Bit mask for UART_S2_MSBF. */
#define BS_UART_S2_MSBF      (1U)          /*!< Bit field size in bits for UART_S2_MSBF. */

/*! @brief Read current value of the UART_S2_MSBF field. */
#define BR_UART_S2_MSBF(x)   (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF, BS_UART_S2_MSBF))

/*! @brief Format value for bitfield UART_S2_MSBF. */
#define BF_UART_S2_MSBF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S2_MSBF) & BM_UART_S2_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_UART_S2_MSBF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_MSBF), BP_UART_S2_MSBF, 1))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART_S2_RXEDGIF   (6U)          /*!< Bit position for UART_S2_RXEDGIF. */
#define BM_UART_S2_RXEDGIF   (0x40U)       /*!< Bit mask for UART_S2_RXEDGIF. */
#define BS_UART_S2_RXEDGIF   (1U)          /*!< Bit field size in bits for UART_S2_RXEDGIF. */

/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define BR_UART_S2_RXEDGIF(x) (BME_UBFX8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF, BS_UART_S2_RXEDGIF))

/*! @brief Format value for bitfield UART_S2_RXEDGIF. */
#define BF_UART_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXEDGIF) & BM_UART_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART_S2_RXEDGIF(x, v) (BME_BFI8(HW_UART_S2_ADDR(x), ((uint8_t)(v) << BP_UART_S2_RXEDGIF), BP_UART_S2_RXEDGIF, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
typedef union _hw_uart_c3
{
    uint8_t U;
    struct _hw_uart_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Error Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion. */
        uint8_t TXDIR : 1;             /*!< [5] Transmitter Pin Data Direction in
                                        * Single-Wire mode */
        uint8_t T8 : 1;                /*!< [6] Transmit Bit 8 */
        uint8_t R8 : 1;                /*!< [7] Received Bit 8 */
    } B;
} hw_uart_c3_t;

/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define HW_UART_C3_ADDR(x)       ((x) + 0x6U)

#define HW_UART_C3(x)            (*(__IO hw_uart_c3_t *) HW_UART_C3_ADDR(x))
#define HW_UART_C3_RD(x)         (HW_UART_C3(x).U)
#define HW_UART_C3_WR(x, v)      (HW_UART_C3(x).U = (v))
#define HW_UART_C3_SET(x, v)     (BME_OR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
#define HW_UART_C3_CLR(x, v)     (BME_AND8(HW_UART_C3_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C3_TOG(x, v)     (BME_XOR8(HW_UART_C3_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_PEIE      (0U)          /*!< Bit position for UART_C3_PEIE. */
#define BM_UART_C3_PEIE      (0x01U)       /*!< Bit mask for UART_C3_PEIE. */
#define BS_UART_C3_PEIE      (1U)          /*!< Bit field size in bits for UART_C3_PEIE. */

/*! @brief Read current value of the UART_C3_PEIE field. */
#define BR_UART_C3_PEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE, BS_UART_C3_PEIE))

/*! @brief Format value for bitfield UART_C3_PEIE. */
#define BF_UART_C3_PEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_PEIE) & BM_UART_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART_C3_PEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_PEIE), BP_UART_C3_PEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_FEIE      (1U)          /*!< Bit position for UART_C3_FEIE. */
#define BM_UART_C3_FEIE      (0x02U)       /*!< Bit mask for UART_C3_FEIE. */
#define BS_UART_C3_FEIE      (1U)          /*!< Bit field size in bits for UART_C3_FEIE. */

/*! @brief Read current value of the UART_C3_FEIE field. */
#define BR_UART_C3_FEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE, BS_UART_C3_FEIE))

/*! @brief Format value for bitfield UART_C3_FEIE. */
#define BF_UART_C3_FEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_FEIE) & BM_UART_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART_C3_FEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_FEIE), BP_UART_C3_FEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_NEIE      (2U)          /*!< Bit position for UART_C3_NEIE. */
#define BM_UART_C3_NEIE      (0x04U)       /*!< Bit mask for UART_C3_NEIE. */
#define BS_UART_C3_NEIE      (1U)          /*!< Bit field size in bits for UART_C3_NEIE. */

/*! @brief Read current value of the UART_C3_NEIE field. */
#define BR_UART_C3_NEIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE, BS_UART_C3_NEIE))

/*! @brief Format value for bitfield UART_C3_NEIE. */
#define BF_UART_C3_NEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_NEIE) & BM_UART_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART_C3_NEIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_NEIE), BP_UART_C3_NEIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_ORIE      (3U)          /*!< Bit position for UART_C3_ORIE. */
#define BM_UART_C3_ORIE      (0x08U)       /*!< Bit mask for UART_C3_ORIE. */
#define BS_UART_C3_ORIE      (1U)          /*!< Bit field size in bits for UART_C3_ORIE. */

/*! @brief Read current value of the UART_C3_ORIE field. */
#define BR_UART_C3_ORIE(x)   (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE, BS_UART_C3_ORIE))

/*! @brief Format value for bitfield UART_C3_ORIE. */
#define BF_UART_C3_ORIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_ORIE) & BM_UART_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART_C3_ORIE(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_ORIE), BP_UART_C3_ORIE, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. This field is
 * automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and an
 * initial character is detected in T = 0 protocol mode. Setting TXINV inverts all
 * transmitted values, including idle, break, start, and stop bits. In loop mode, if
 * TXINV is set, the receiver gets the transmit inversion bit when RXINV is
 * disabled. When C7816[ISO7816E] is set/enabled then only the transmitted data bits
 * and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
#define BP_UART_C3_TXINV     (4U)          /*!< Bit position for UART_C3_TXINV. */
#define BM_UART_C3_TXINV     (0x10U)       /*!< Bit mask for UART_C3_TXINV. */
#define BS_UART_C3_TXINV     (1U)          /*!< Bit field size in bits for UART_C3_TXINV. */

/*! @brief Read current value of the UART_C3_TXINV field. */
#define BR_UART_C3_TXINV(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV, BS_UART_C3_TXINV))

/*! @brief Format value for bitfield UART_C3_TXINV. */
#define BF_UART_C3_TXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXINV) & BM_UART_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART_C3_TXINV(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXINV), BP_UART_C3_TXINV, 1))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single wire mode.
 * - 1 - TXD pin is an output in single wire mode.
 */
/*@{*/
#define BP_UART_C3_TXDIR     (5U)          /*!< Bit position for UART_C3_TXDIR. */
#define BM_UART_C3_TXDIR     (0x20U)       /*!< Bit mask for UART_C3_TXDIR. */
#define BS_UART_C3_TXDIR     (1U)          /*!< Bit field size in bits for UART_C3_TXDIR. */

/*! @brief Read current value of the UART_C3_TXDIR field. */
#define BR_UART_C3_TXDIR(x)  (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR, BS_UART_C3_TXDIR))

/*! @brief Format value for bitfield UART_C3_TXDIR. */
#define BF_UART_C3_TXDIR(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXDIR) & BM_UART_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART_C3_TXDIR(x, v) (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_TXDIR), BP_UART_C3_TXDIR, 1))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
#define BP_UART_C3_T8        (6U)          /*!< Bit position for UART_C3_T8. */
#define BM_UART_C3_T8        (0x40U)       /*!< Bit mask for UART_C3_T8. */
#define BS_UART_C3_T8        (1U)          /*!< Bit field size in bits for UART_C3_T8. */

/*! @brief Read current value of the UART_C3_T8 field. */
#define BR_UART_C3_T8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_T8, BS_UART_C3_T8))

/*! @brief Format value for bitfield UART_C3_T8. */
#define BF_UART_C3_T8(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C3_T8) & BM_UART_C3_T8)

/*! @brief Set the T8 field to a new value. */
#define BW_UART_C3_T8(x, v)  (BME_BFI8(HW_UART_C3_ADDR(x), ((uint8_t)(v) << BP_UART_C3_T8), BP_UART_C3_T8, 1))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
#define BP_UART_C3_R8        (7U)          /*!< Bit position for UART_C3_R8. */
#define BM_UART_C3_R8        (0x80U)       /*!< Bit mask for UART_C3_R8. */
#define BS_UART_C3_R8        (1U)          /*!< Bit field size in bits for UART_C3_R8. */

/*! @brief Read current value of the UART_C3_R8 field. */
#define BR_UART_C3_R8(x)     (BME_UBFX8(HW_UART_C3_ADDR(x), BP_UART_C3_R8, BS_UART_C3_R8))
/*@}*/

/*******************************************************************************
 * HW_UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
typedef union _hw_uart_d
{
    uint8_t U;
    struct _hw_uart_d_bitfields
    {
        uint8_t RT : 8;                /*!< [7:0]  */
    } B;
} hw_uart_d_t;

/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define HW_UART_D_ADDR(x)        ((x) + 0x7U)

#define HW_UART_D(x)             (*(__IO hw_uart_d_t *) HW_UART_D_ADDR(x))
#define HW_UART_D_RD(x)          (HW_UART_D(x).U)
#define HW_UART_D_WR(x, v)       (HW_UART_D(x).U = (v))
#define HW_UART_D_SET(x, v)      (BME_OR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
#define HW_UART_D_CLR(x, v)      (BME_AND8(HW_UART_D_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_D_TOG(x, v)      (BME_XOR8(HW_UART_D_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_D bitfields
 */

/*!
 * @name Register UART_D, field RT[7:0] (RW)
 *
 * Reads return the contents of the read-only receive data register and writes
 * go to the write-only transmit data register.
 */
/*@{*/
#define BP_UART_D_RT         (0U)          /*!< Bit position for UART_D_RT. */
#define BM_UART_D_RT         (0xFFU)       /*!< Bit mask for UART_D_RT. */
#define BS_UART_D_RT         (8U)          /*!< Bit field size in bits for UART_D_RT. */

/*! @brief Read current value of the UART_D_RT field. */
#define BR_UART_D_RT(x)      (HW_UART_D(x).U)

/*! @brief Format value for bitfield UART_D_RT. */
#define BF_UART_D_RT(v)      ((uint8_t)((uint8_t)(v) << BP_UART_D_RT) & BM_UART_D_RT)

/*! @brief Set the RT field to a new value. */
#define BW_UART_D_RT(x, v)   (HW_UART_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief HW_UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
typedef union _hw_uart_ma1
{
    uint8_t U;
    struct _hw_uart_ma1_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma1_t;

/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define HW_UART_MA1_ADDR(x)      ((x) + 0x8U)

#define HW_UART_MA1(x)           (*(__IO hw_uart_ma1_t *) HW_UART_MA1_ADDR(x))
#define HW_UART_MA1_RD(x)        (HW_UART_MA1(x).U)
#define HW_UART_MA1_WR(x, v)     (HW_UART_MA1(x).U = (v))
#define HW_UART_MA1_SET(x, v)    (BME_OR8(HW_UART_MA1_ADDR(x), (uint8_t)(v)))
#define HW_UART_MA1_CLR(x, v)    (BME_AND8(HW_UART_MA1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_MA1_TOG(x, v)    (BME_XOR8(HW_UART_MA1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA1 bitfields
 */

/*!
 * @name Register UART_MA1, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA1_MA       (0U)          /*!< Bit position for UART_MA1_MA. */
#define BM_UART_MA1_MA       (0xFFU)       /*!< Bit mask for UART_MA1_MA. */
#define BS_UART_MA1_MA       (8U)          /*!< Bit field size in bits for UART_MA1_MA. */

/*! @brief Read current value of the UART_MA1_MA field. */
#define BR_UART_MA1_MA(x)    (HW_UART_MA1(x).U)

/*! @brief Format value for bitfield UART_MA1_MA. */
#define BF_UART_MA1_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA1_MA) & BM_UART_MA1_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA1_MA(x, v) (HW_UART_MA1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief HW_UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
typedef union _hw_uart_ma2
{
    uint8_t U;
    struct _hw_uart_ma2_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma2_t;

/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define HW_UART_MA2_ADDR(x)      ((x) + 0x9U)

#define HW_UART_MA2(x)           (*(__IO hw_uart_ma2_t *) HW_UART_MA2_ADDR(x))
#define HW_UART_MA2_RD(x)        (HW_UART_MA2(x).U)
#define HW_UART_MA2_WR(x, v)     (HW_UART_MA2(x).U = (v))
#define HW_UART_MA2_SET(x, v)    (BME_OR8(HW_UART_MA2_ADDR(x), (uint8_t)(v)))
#define HW_UART_MA2_CLR(x, v)    (BME_AND8(HW_UART_MA2_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_MA2_TOG(x, v)    (BME_XOR8(HW_UART_MA2_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA2 bitfields
 */

/*!
 * @name Register UART_MA2, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA2_MA       (0U)          /*!< Bit position for UART_MA2_MA. */
#define BM_UART_MA2_MA       (0xFFU)       /*!< Bit mask for UART_MA2_MA. */
#define BS_UART_MA2_MA       (8U)          /*!< Bit field size in bits for UART_MA2_MA. */

/*! @brief Read current value of the UART_MA2_MA field. */
#define BR_UART_MA2_MA(x)    (HW_UART_MA2(x).U)

/*! @brief Format value for bitfield UART_MA2_MA. */
#define BF_UART_MA2_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA2_MA) & BM_UART_MA2_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA2_MA(x, v) (HW_UART_MA2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c4
{
    uint8_t U;
    struct _hw_uart_c4_bitfields
    {
        uint8_t BRFA : 5;              /*!< [4:0] Baud Rate Fine Adjust */
        uint8_t M10 : 1;               /*!< [5] 10-bit Mode select */
        uint8_t MAEN2 : 1;             /*!< [6] Match Address Mode Enable 2 */
        uint8_t MAEN1 : 1;             /*!< [7] Match Address Mode Enable 1 */
    } B;
} hw_uart_c4_t;

/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define HW_UART_C4_ADDR(x)       ((x) + 0xAU)

#define HW_UART_C4(x)            (*(__IO hw_uart_c4_t *) HW_UART_C4_ADDR(x))
#define HW_UART_C4_RD(x)         (HW_UART_C4(x).U)
#define HW_UART_C4_WR(x, v)      (HW_UART_C4(x).U = (v))
#define HW_UART_C4_SET(x, v)     (BME_OR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
#define HW_UART_C4_CLR(x, v)     (BME_AND8(HW_UART_C4_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C4_TOG(x, v)     (BME_XOR8(HW_UART_C4_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
#define BP_UART_C4_BRFA      (0U)          /*!< Bit position for UART_C4_BRFA. */
#define BM_UART_C4_BRFA      (0x1FU)       /*!< Bit mask for UART_C4_BRFA. */
#define BS_UART_C4_BRFA      (5U)          /*!< Bit field size in bits for UART_C4_BRFA. */

/*! @brief Read current value of the UART_C4_BRFA field. */
#define BR_UART_C4_BRFA(x)   (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_BRFA, BS_UART_C4_BRFA))

/*! @brief Format value for bitfield UART_C4_BRFA. */
#define BF_UART_C4_BRFA(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C4_BRFA) & BM_UART_C4_BRFA)

/*! @brief Set the BRFA field to a new value. */
#define BW_UART_C4_BRFA(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_BRFA), BP_UART_C4_BRFA, 5))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. If M10 is set,
 * then both C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more
 * information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
#define BP_UART_C4_M10       (5U)          /*!< Bit position for UART_C4_M10. */
#define BM_UART_C4_M10       (0x20U)       /*!< Bit mask for UART_C4_M10. */
#define BS_UART_C4_M10       (1U)          /*!< Bit field size in bits for UART_C4_M10. */

/*! @brief Read current value of the UART_C4_M10 field. */
#define BR_UART_C4_M10(x)    (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_M10, BS_UART_C4_M10))

/*! @brief Format value for bitfield UART_C4_M10. */
#define BF_UART_C4_M10(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C4_M10) & BM_UART_C4_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_UART_C4_M10(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_M10), BP_UART_C4_M10, 1))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN2     (6U)          /*!< Bit position for UART_C4_MAEN2. */
#define BM_UART_C4_MAEN2     (0x40U)       /*!< Bit mask for UART_C4_MAEN2. */
#define BS_UART_C4_MAEN2     (1U)          /*!< Bit field size in bits for UART_C4_MAEN2. */

/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define BR_UART_C4_MAEN2(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2, BS_UART_C4_MAEN2))

/*! @brief Format value for bitfield UART_C4_MAEN2. */
#define BF_UART_C4_MAEN2(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN2) & BM_UART_C4_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_UART_C4_MAEN2(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_MAEN2), BP_UART_C4_MAEN2, 1))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer. This field must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN1     (7U)          /*!< Bit position for UART_C4_MAEN1. */
#define BM_UART_C4_MAEN1     (0x80U)       /*!< Bit mask for UART_C4_MAEN1. */
#define BS_UART_C4_MAEN1     (1U)          /*!< Bit field size in bits for UART_C4_MAEN1. */

/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define BR_UART_C4_MAEN1(x)  (BME_UBFX8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1, BS_UART_C4_MAEN1))

/*! @brief Format value for bitfield UART_C4_MAEN1. */
#define BF_UART_C4_MAEN1(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN1) & BM_UART_C4_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_UART_C4_MAEN1(x, v) (BME_BFI8(HW_UART_C4_ADDR(x), ((uint8_t)(v) << BP_UART_C4_MAEN1), BP_UART_C4_MAEN1, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c5
{
    uint8_t U;
    struct _hw_uart_c5_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RDMAS : 1;             /*!< [5] Receiver Full DMA Select */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t TDMAS : 1;             /*!< [7] Transmitter DMA Select */
    } B;
} hw_uart_c5_t;

/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define HW_UART_C5_ADDR(x)       ((x) + 0xBU)

#define HW_UART_C5(x)            (*(__IO hw_uart_c5_t *) HW_UART_C5_ADDR(x))
#define HW_UART_C5_RD(x)         (HW_UART_C5(x).U)
#define HW_UART_C5_WR(x, v)      (HW_UART_C5(x).U = (v))
#define HW_UART_C5_SET(x, v)     (BME_OR8(HW_UART_C5_ADDR(x), (uint8_t)(v)))
#define HW_UART_C5_CLR(x, v)     (BME_AND8(HW_UART_C5_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C5_TOG(x, v)     (BME_XOR8(HW_UART_C5_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_RDMAS     (5U)          /*!< Bit position for UART_C5_RDMAS. */
#define BM_UART_C5_RDMAS     (0x20U)       /*!< Bit mask for UART_C5_RDMAS. */
#define BS_UART_C5_RDMAS     (1U)          /*!< Bit field size in bits for UART_C5_RDMAS. */

/*! @brief Read current value of the UART_C5_RDMAS field. */
#define BR_UART_C5_RDMAS(x)  (BME_UBFX8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS, BS_UART_C5_RDMAS))

/*! @brief Format value for bitfield UART_C5_RDMAS. */
#define BF_UART_C5_RDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_RDMAS) & BM_UART_C5_RDMAS)

/*! @brief Set the RDMAS field to a new value. */
#define BW_UART_C5_RDMAS(x, v) (BME_BFI8(HW_UART_C5_ADDR(x), ((uint8_t)(v) << BP_UART_C5_RDMAS), BP_UART_C5_RDMAS, 1))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_TDMAS     (7U)          /*!< Bit position for UART_C5_TDMAS. */
#define BM_UART_C5_TDMAS     (0x80U)       /*!< Bit mask for UART_C5_TDMAS. */
#define BS_UART_C5_TDMAS     (1U)          /*!< Bit field size in bits for UART_C5_TDMAS. */

/*! @brief Read current value of the UART_C5_TDMAS field. */
#define BR_UART_C5_TDMAS(x)  (BME_UBFX8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS, BS_UART_C5_TDMAS))

/*! @brief Format value for bitfield UART_C5_TDMAS. */
#define BF_UART_C5_TDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_TDMAS) & BM_UART_C5_TDMAS)

/*! @brief Set the TDMAS field to a new value. */
#define BW_UART_C5_TDMAS(x, v) (BME_BFI8(HW_UART_C5_ADDR(x), ((uint8_t)(v) << BP_UART_C5_TDMAS), BP_UART_C5_TDMAS, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
typedef union _hw_uart_c7816
{
    uint8_t U;
    struct _hw_uart_c7816_bitfields
    {
        uint8_t ISO_7816E : 1;         /*!< [0] ISO-7816 Functionality Enabled */
        uint8_t TTYPE : 1;             /*!< [1] Transfer Type */
        uint8_t INIT : 1;              /*!< [2] Detect Initial Character */
        uint8_t ANACK : 1;             /*!< [3] Generate NACK on Error */
        uint8_t ONACK : 1;             /*!< [4] Generate NACK on Overflow */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_c7816_t;

/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define HW_UART_C7816_ADDR(x)    ((x) + 0x18U)

#define HW_UART_C7816(x)         (*(__IO hw_uart_c7816_t *) HW_UART_C7816_ADDR(x))
#define HW_UART_C7816_RD(x)      (HW_UART_C7816(x).U)
#define HW_UART_C7816_WR(x, v)   (HW_UART_C7816(x).U = (v))
#define HW_UART_C7816_SET(x, v)  (BME_OR8(HW_UART_C7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_C7816_CLR(x, v)  (BME_AND8(HW_UART_C7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_C7816_TOG(x, v)  (BME_XOR8(HW_UART_C7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off/not enabled.
 * - 1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
#define BP_UART_C7816_ISO_7816E (0U)       /*!< Bit position for UART_C7816_ISO_7816E. */
#define BM_UART_C7816_ISO_7816E (0x01U)    /*!< Bit mask for UART_C7816_ISO_7816E. */
#define BS_UART_C7816_ISO_7816E (1U)       /*!< Bit field size in bits for UART_C7816_ISO_7816E. */

/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define BR_UART_C7816_ISO_7816E(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E, BS_UART_C7816_ISO_7816E))

/*! @brief Format value for bitfield UART_C7816_ISO_7816E. */
#define BF_UART_C7816_ISO_7816E(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ISO_7816E) & BM_UART_C7816_ISO_7816E)

/*! @brief Set the ISO_7816E field to a new value. */
#define BW_UART_C7816_ISO_7816E(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ISO_7816E), BP_UART_C7816_ISO_7816E, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0 - T = 0 per the ISO-7816 specification.
 * - 1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
#define BP_UART_C7816_TTYPE  (1U)          /*!< Bit position for UART_C7816_TTYPE. */
#define BM_UART_C7816_TTYPE  (0x02U)       /*!< Bit mask for UART_C7816_TTYPE. */
#define BS_UART_C7816_TTYPE  (1U)          /*!< Bit field size in bits for UART_C7816_TTYPE. */

/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define BR_UART_C7816_TTYPE(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE, BS_UART_C7816_TTYPE))

/*! @brief Format value for bitfield UART_C7816_TTYPE. */
#define BF_UART_C7816_TTYPE(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_TTYPE) & BM_UART_C7816_TTYPE)

/*! @brief Set the TTYPE field to a new value. */
#define BW_UART_C7816_TTYPE(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_TTYPE), BP_UART_C7816_TTYPE, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[ADT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detecting a
 * valid initial character, the configuration values S2[MSBF], C3[TXINV], and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character, IS7816[INITD] is set and an
 * interrupt issued as programmed by IE7816[INITDE]. When a valid initial
 * character is detected, INIT is automatically cleared. This Initial Character Detect
 * feature is supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
#define BP_UART_C7816_INIT   (2U)          /*!< Bit position for UART_C7816_INIT. */
#define BM_UART_C7816_INIT   (0x04U)       /*!< Bit mask for UART_C7816_INIT. */
#define BS_UART_C7816_INIT   (1U)          /*!< Bit field size in bits for UART_C7816_INIT. */

/*! @brief Read current value of the UART_C7816_INIT field. */
#define BR_UART_C7816_INIT(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT, BS_UART_C7816_INIT))

/*! @brief Format value for bitfield UART_C7816_INIT. */
#define BF_UART_C7816_INIT(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_INIT) & BM_UART_C7816_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_UART_C7816_INIT(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_INIT), BP_UART_C7816_INIT, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
#define BP_UART_C7816_ANACK  (3U)          /*!< Bit position for UART_C7816_ANACK. */
#define BM_UART_C7816_ANACK  (0x08U)       /*!< Bit mask for UART_C7816_ANACK. */
#define BS_UART_C7816_ANACK  (1U)          /*!< Bit field size in bits for UART_C7816_ANACK. */

/*! @brief Read current value of the UART_C7816_ANACK field. */
#define BR_UART_C7816_ANACK(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK, BS_UART_C7816_ANACK))

/*! @brief Format value for bitfield UART_C7816_ANACK. */
#define BF_UART_C7816_ANACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ANACK) & BM_UART_C7816_ANACK)

/*! @brief Set the ANACK field to a new value. */
#define BW_UART_C7816_ANACK(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ANACK), BP_UART_C7816_ANACK, 1))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
#define BP_UART_C7816_ONACK  (4U)          /*!< Bit position for UART_C7816_ONACK. */
#define BM_UART_C7816_ONACK  (0x10U)       /*!< Bit mask for UART_C7816_ONACK. */
#define BS_UART_C7816_ONACK  (1U)          /*!< Bit field size in bits for UART_C7816_ONACK. */

/*! @brief Read current value of the UART_C7816_ONACK field. */
#define BR_UART_C7816_ONACK(x) (BME_UBFX8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK, BS_UART_C7816_ONACK))

/*! @brief Format value for bitfield UART_C7816_ONACK. */
#define BF_UART_C7816_ONACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ONACK) & BM_UART_C7816_ONACK)

/*! @brief Set the ONACK field to a new value. */
#define BW_UART_C7816_ONACK(x, v) (BME_BFI8(HW_UART_C7816_ADDR(x), ((uint8_t)(v) << BP_UART_C7816_ONACK), BP_UART_C7816_ONACK, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
typedef union _hw_uart_ie7816
{
    uint8_t U;
    struct _hw_uart_ie7816_bitfields
    {
        uint8_t RXTE : 1;              /*!< [0] Receive Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t TXTE : 1;              /*!< [1] Transmit Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t GTVE : 1;              /*!< [2] Guard Timer Violated Interrupt Enable */
        uint8_t ADTE : 1;              /*!< [3] ATR Duration Timer Interrupt Enable */
        uint8_t INITDE : 1;            /*!< [4] Initial Character Detected Interrupt
                                        * Enable */
        uint8_t BWTE : 1;              /*!< [5] Block Wait Timer Interrupt Enable */
        uint8_t CWTE : 1;              /*!< [6] Character Wait Timer Interrupt Enable */
        uint8_t WTE : 1;               /*!< [7] Wait Timer Interrupt Enable */
    } B;
} hw_uart_ie7816_t;

/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define HW_UART_IE7816_ADDR(x)   ((x) + 0x19U)

#define HW_UART_IE7816(x)        (*(__IO hw_uart_ie7816_t *) HW_UART_IE7816_ADDR(x))
#define HW_UART_IE7816_RD(x)     (HW_UART_IE7816(x).U)
#define HW_UART_IE7816_WR(x, v)  (HW_UART_IE7816(x).U = (v))
#define HW_UART_IE7816_SET(x, v) (BME_OR8(HW_UART_IE7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_IE7816_CLR(x, v) (BME_AND8(HW_UART_IE7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_IE7816_TOG(x, v) (BME_XOR8(HW_UART_IE7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[RXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_RXTE  (0U)          /*!< Bit position for UART_IE7816_RXTE. */
#define BM_UART_IE7816_RXTE  (0x01U)       /*!< Bit mask for UART_IE7816_RXTE. */
#define BS_UART_IE7816_RXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_RXTE. */

/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define BR_UART_IE7816_RXTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE, BS_UART_IE7816_RXTE))

/*! @brief Format value for bitfield UART_IE7816_RXTE. */
#define BF_UART_IE7816_RXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_RXTE) & BM_UART_IE7816_RXTE)

/*! @brief Set the RXTE field to a new value. */
#define BW_UART_IE7816_RXTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_RXTE), BP_UART_IE7816_RXTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[TXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_TXTE  (1U)          /*!< Bit position for UART_IE7816_TXTE. */
#define BM_UART_IE7816_TXTE  (0x02U)       /*!< Bit mask for UART_IE7816_TXTE. */
#define BS_UART_IE7816_TXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_TXTE. */

/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define BR_UART_IE7816_TXTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE, BS_UART_IE7816_TXTE))

/*! @brief Format value for bitfield UART_IE7816_TXTE. */
#define BF_UART_IE7816_TXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_TXTE) & BM_UART_IE7816_TXTE)

/*! @brief Set the TXTE field to a new value. */
#define BW_UART_IE7816_TXTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_TXTE), BP_UART_IE7816_TXTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[GTV] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_GTVE  (2U)          /*!< Bit position for UART_IE7816_GTVE. */
#define BM_UART_IE7816_GTVE  (0x04U)       /*!< Bit mask for UART_IE7816_GTVE. */
#define BS_UART_IE7816_GTVE  (1U)          /*!< Bit field size in bits for UART_IE7816_GTVE. */

/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define BR_UART_IE7816_GTVE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE, BS_UART_IE7816_GTVE))

/*! @brief Format value for bitfield UART_IE7816_GTVE. */
#define BF_UART_IE7816_GTVE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_GTVE) & BM_UART_IE7816_GTVE)

/*! @brief Set the GTVE field to a new value. */
#define BW_UART_IE7816_GTVE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_GTVE), BP_UART_IE7816_GTVE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field ADTE[3] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[ADT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[ADT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_ADTE  (3U)          /*!< Bit position for UART_IE7816_ADTE. */
#define BM_UART_IE7816_ADTE  (0x08U)       /*!< Bit mask for UART_IE7816_ADTE. */
#define BS_UART_IE7816_ADTE  (1U)          /*!< Bit field size in bits for UART_IE7816_ADTE. */

/*! @brief Read current value of the UART_IE7816_ADTE field. */
#define BR_UART_IE7816_ADTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_ADTE, BS_UART_IE7816_ADTE))

/*! @brief Format value for bitfield UART_IE7816_ADTE. */
#define BF_UART_IE7816_ADTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_ADTE) & BM_UART_IE7816_ADTE)

/*! @brief Set the ADTE field to a new value. */
#define BW_UART_IE7816_ADTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_ADTE), BP_UART_IE7816_ADTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[INITD] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
#define BP_UART_IE7816_INITDE (4U)         /*!< Bit position for UART_IE7816_INITDE. */
#define BM_UART_IE7816_INITDE (0x10U)      /*!< Bit mask for UART_IE7816_INITDE. */
#define BS_UART_IE7816_INITDE (1U)         /*!< Bit field size in bits for UART_IE7816_INITDE. */

/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define BR_UART_IE7816_INITDE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE, BS_UART_IE7816_INITDE))

/*! @brief Format value for bitfield UART_IE7816_INITDE. */
#define BF_UART_IE7816_INITDE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_INITDE) & BM_UART_IE7816_INITDE)

/*! @brief Set the INITDE field to a new value. */
#define BW_UART_IE7816_INITDE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_INITDE), BP_UART_IE7816_INITDE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[BWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_BWTE  (5U)          /*!< Bit position for UART_IE7816_BWTE. */
#define BM_UART_IE7816_BWTE  (0x20U)       /*!< Bit mask for UART_IE7816_BWTE. */
#define BS_UART_IE7816_BWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_BWTE. */

/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define BR_UART_IE7816_BWTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE, BS_UART_IE7816_BWTE))

/*! @brief Format value for bitfield UART_IE7816_BWTE. */
#define BF_UART_IE7816_BWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_BWTE) & BM_UART_IE7816_BWTE)

/*! @brief Set the BWTE field to a new value. */
#define BW_UART_IE7816_BWTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_BWTE), BP_UART_IE7816_BWTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[CWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_CWTE  (6U)          /*!< Bit position for UART_IE7816_CWTE. */
#define BM_UART_IE7816_CWTE  (0x40U)       /*!< Bit mask for UART_IE7816_CWTE. */
#define BS_UART_IE7816_CWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_CWTE. */

/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define BR_UART_IE7816_CWTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE, BS_UART_IE7816_CWTE))

/*! @brief Format value for bitfield UART_IE7816_CWTE. */
#define BF_UART_IE7816_CWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_CWTE) & BM_UART_IE7816_CWTE)

/*! @brief Set the CWTE field to a new value. */
#define BW_UART_IE7816_CWTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_CWTE), BP_UART_IE7816_CWTE, 1))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_WTE   (7U)          /*!< Bit position for UART_IE7816_WTE. */
#define BM_UART_IE7816_WTE   (0x80U)       /*!< Bit mask for UART_IE7816_WTE. */
#define BS_UART_IE7816_WTE   (1U)          /*!< Bit field size in bits for UART_IE7816_WTE. */

/*! @brief Read current value of the UART_IE7816_WTE field. */
#define BR_UART_IE7816_WTE(x) (BME_UBFX8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE, BS_UART_IE7816_WTE))

/*! @brief Format value for bitfield UART_IE7816_WTE. */
#define BF_UART_IE7816_WTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_WTE) & BM_UART_IE7816_WTE)

/*! @brief Set the WTE field to a new value. */
#define BW_UART_IE7816_WTE(x, v) (BME_BFI8(HW_UART_IE7816_ADDR(x), ((uint8_t)(v) << BP_UART_IE7816_WTE), BP_UART_IE7816_WTE, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IS7816 - UART 7816 Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
typedef union _hw_uart_is7816
{
    uint8_t U;
    struct _hw_uart_is7816_bitfields
    {
        uint8_t RXT : 1;               /*!< [0] Receive Threshold Exceeded Interrupt */
        uint8_t TXT : 1;               /*!< [1] Transmit Threshold Exceeded Interrupt */
        uint8_t GTV : 1;               /*!< [2] Guard Timer Violated Interrupt */
        uint8_t ADT : 1;               /*!< [3] ATR Duration Time Interrupt */
        uint8_t INITD : 1;             /*!< [4] Initial Character Detected Interrupt */
        uint8_t BWT : 1;               /*!< [5] Block Wait Timer Interrupt */
        uint8_t CWT : 1;               /*!< [6] Character Wait Timer Interrupt */
        uint8_t WT : 1;                /*!< [7] Wait Timer Interrupt */
    } B;
} hw_uart_is7816_t;

/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define HW_UART_IS7816_ADDR(x)   ((x) + 0x1AU)

#define HW_UART_IS7816(x)        (*(__IO hw_uart_is7816_t *) HW_UART_IS7816_ADDR(x))
#define HW_UART_IS7816_RD(x)     (HW_UART_IS7816(x).U)
#define HW_UART_IS7816_WR(x, v)  (HW_UART_IS7816(x).U = (v))
#define HW_UART_IS7816_SET(x, v) (BME_OR8(HW_UART_IS7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_IS7816_CLR(x, v) (BME_AND8(HW_UART_IS7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_IS7816_TOG(x, v) (BME_XOR8(HW_UART_IS7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_RXT   (0U)          /*!< Bit position for UART_IS7816_RXT. */
#define BM_UART_IS7816_RXT   (0x01U)       /*!< Bit mask for UART_IS7816_RXT. */
#define BS_UART_IS7816_RXT   (1U)          /*!< Bit field size in bits for UART_IS7816_RXT. */

/*! @brief Read current value of the UART_IS7816_RXT field. */
#define BR_UART_IS7816_RXT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT, BS_UART_IS7816_RXT))

/*! @brief Format value for bitfield UART_IS7816_RXT. */
#define BF_UART_IS7816_RXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_RXT) & BM_UART_IS7816_RXT)

/*! @brief Set the RXT field to a new value. */
#define BW_UART_IS7816_RXT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_RXT), BP_UART_IS7816_RXT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in ET7816[TXTHRESHOLD].
 * - 1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_TXT   (1U)          /*!< Bit position for UART_IS7816_TXT. */
#define BM_UART_IS7816_TXT   (0x02U)       /*!< Bit mask for UART_IS7816_TXT. */
#define BS_UART_IS7816_TXT   (1U)          /*!< Bit field size in bits for UART_IS7816_TXT. */

/*! @brief Read current value of the UART_IS7816_TXT field. */
#define BR_UART_IS7816_TXT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT, BS_UART_IS7816_TXT))

/*! @brief Format value for bitfield UART_IS7816_TXT. */
#define BF_UART_IS7816_TXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_TXT) & BM_UART_IS7816_TXT)

/*! @brief Set the TXT field to a new value. */
#define BW_UART_IS7816_TXT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_TXT), BP_UART_IS7816_TXT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_GTV   (2U)          /*!< Bit position for UART_IS7816_GTV. */
#define BM_UART_IS7816_GTV   (0x04U)       /*!< Bit mask for UART_IS7816_GTV. */
#define BS_UART_IS7816_GTV   (1U)          /*!< Bit field size in bits for UART_IS7816_GTV. */

/*! @brief Read current value of the UART_IS7816_GTV field. */
#define BR_UART_IS7816_GTV(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV, BS_UART_IS7816_GTV))

/*! @brief Format value for bitfield UART_IS7816_GTV. */
#define BF_UART_IS7816_GTV(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_GTV) & BM_UART_IS7816_GTV)

/*! @brief Set the GTV field to a new value. */
#define BW_UART_IS7816_GTV(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_GTV), BP_UART_IS7816_GTV, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field ADT[3] (W1C)
 *
 * Indicates that the ATR duration time, the time between the leading edge of
 * the TS character being received and the leading edge of the next response
 * character, has exceeded the programmed value. This flag asserts only when
 * C7816[TTYPE] = 0. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - ATR Duration time (ADT) has not been violated.
 * - 1 - ATR Duration time (ADT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_ADT   (3U)          /*!< Bit position for UART_IS7816_ADT. */
#define BM_UART_IS7816_ADT   (0x08U)       /*!< Bit mask for UART_IS7816_ADT. */
#define BS_UART_IS7816_ADT   (1U)          /*!< Bit field size in bits for UART_IS7816_ADT. */

/*! @brief Read current value of the UART_IS7816_ADT field. */
#define BR_UART_IS7816_ADT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_ADT, BS_UART_IS7816_ADT))

/*! @brief Format value for bitfield UART_IS7816_ADT. */
#define BF_UART_IS7816_ADT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_ADT) & BM_UART_IS7816_ADT)

/*! @brief Set the ADT field to a new value. */
#define BW_UART_IS7816_ADT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_ADT), BP_UART_IS7816_ADT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
#define BP_UART_IS7816_INITD (4U)          /*!< Bit position for UART_IS7816_INITD. */
#define BM_UART_IS7816_INITD (0x10U)       /*!< Bit mask for UART_IS7816_INITD. */
#define BS_UART_IS7816_INITD (1U)          /*!< Bit field size in bits for UART_IS7816_INITD. */

/*! @brief Read current value of the UART_IS7816_INITD field. */
#define BR_UART_IS7816_INITD(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD, BS_UART_IS7816_INITD))

/*! @brief Format value for bitfield UART_IS7816_INITD. */
#define BF_UART_IS7816_INITD(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_INITD) & BM_UART_IS7816_INITD)

/*! @brief Set the INITD field to a new value. */
#define BW_UART_IS7816_INITD(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_INITD), BP_UART_IS7816_INITD, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait time (BWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_BWT   (5U)          /*!< Bit position for UART_IS7816_BWT. */
#define BM_UART_IS7816_BWT   (0x20U)       /*!< Bit mask for UART_IS7816_BWT. */
#define BS_UART_IS7816_BWT   (1U)          /*!< Bit field size in bits for UART_IS7816_BWT. */

/*! @brief Read current value of the UART_IS7816_BWT field. */
#define BR_UART_IS7816_BWT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT, BS_UART_IS7816_BWT))

/*! @brief Format value for bitfield UART_IS7816_BWT. */
#define BF_UART_IS7816_BWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_BWT) & BM_UART_IS7816_BWT)

/*! @brief Set the BWT field to a new value. */
#define BW_UART_IS7816_BWT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_BWT), BP_UART_IS7816_BWT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_CWT   (6U)          /*!< Bit position for UART_IS7816_CWT. */
#define BM_UART_IS7816_CWT   (0x40U)       /*!< Bit mask for UART_IS7816_CWT. */
#define BS_UART_IS7816_CWT   (1U)          /*!< Bit field size in bits for UART_IS7816_CWT. */

/*! @brief Read current value of the UART_IS7816_CWT field. */
#define BR_UART_IS7816_CWT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT, BS_UART_IS7816_CWT))

/*! @brief Format value for bitfield UART_IS7816_CWT. */
#define BF_UART_IS7816_CWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_CWT) & BM_UART_IS7816_CWT)

/*! @brief Set the CWT field to a new value. */
#define BW_UART_IS7816_CWT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_CWT), BP_UART_IS7816_CWT, 1))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_WT    (7U)          /*!< Bit position for UART_IS7816_WT. */
#define BM_UART_IS7816_WT    (0x80U)       /*!< Bit mask for UART_IS7816_WT. */
#define BS_UART_IS7816_WT    (1U)          /*!< Bit field size in bits for UART_IS7816_WT. */

/*! @brief Read current value of the UART_IS7816_WT field. */
#define BR_UART_IS7816_WT(x) (BME_UBFX8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT, BS_UART_IS7816_WT))

/*! @brief Format value for bitfield UART_IS7816_WT. */
#define BF_UART_IS7816_WT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_WT) & BM_UART_IS7816_WT)

/*! @brief Set the WT field to a new value. */
#define BW_UART_IS7816_WT(x, v) (BME_BFI8(HW_UART_IS7816_ADDR(x), ((uint8_t)(v) << BP_UART_IS7816_WT), BP_UART_IS7816_WT, 1))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816 register contains the WTX variable used in the generation of the
 * block wait timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816
{
    uint8_t U;
    struct _hw_uart_wp7816_bitfields
    {
        uint8_t WTX : 8;               /*!< [7:0] Wait Time Multiplier (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816_t;

/*!
 * @name Constants and macros for entire UART_WP7816 register
 */
/*@{*/
#define HW_UART_WP7816_ADDR(x)   ((x) + 0x1BU)

#define HW_UART_WP7816(x)        (*(__IO hw_uart_wp7816_t *) HW_UART_WP7816_ADDR(x))
#define HW_UART_WP7816_RD(x)     (HW_UART_WP7816(x).U)
#define HW_UART_WP7816_WR(x, v)  (HW_UART_WP7816(x).U = (v))
#define HW_UART_WP7816_SET(x, v) (BME_OR8(HW_UART_WP7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816_CLR(x, v) (BME_AND8(HW_UART_WP7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816_TOG(x, v) (BME_XOR8(HW_UART_WP7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816 bitfields
 */

/*!
 * @name Register UART_WP7816, field WTX[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. It represents a value
 * between 0 and 255. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816_WTX   (0U)          /*!< Bit position for UART_WP7816_WTX. */
#define BM_UART_WP7816_WTX   (0xFFU)       /*!< Bit mask for UART_WP7816_WTX. */
#define BS_UART_WP7816_WTX   (8U)          /*!< Bit field size in bits for UART_WP7816_WTX. */

/*! @brief Read current value of the UART_WP7816_WTX field. */
#define BR_UART_WP7816_WTX(x) (HW_UART_WP7816(x).U)

/*! @brief Format value for bitfield UART_WP7816_WTX. */
#define BF_UART_WP7816_WTX(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816_WTX) & BM_UART_WP7816_WTX)

/*! @brief Set the WTX field to a new value. */
#define BW_UART_WP7816_WTX(x, v) (HW_UART_WP7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wn7816
{
    uint8_t U;
    struct _hw_uart_wn7816_bitfields
    {
        uint8_t GTN : 8;               /*!< [7:0] Guard Band N */
    } B;
} hw_uart_wn7816_t;

/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define HW_UART_WN7816_ADDR(x)   ((x) + 0x1CU)

#define HW_UART_WN7816(x)        (*(__IO hw_uart_wn7816_t *) HW_UART_WN7816_ADDR(x))
#define HW_UART_WN7816_RD(x)     (HW_UART_WN7816(x).U)
#define HW_UART_WN7816_WR(x, v)  (HW_UART_WN7816(x).U = (v))
#define HW_UART_WN7816_SET(x, v) (BME_OR8(HW_UART_WN7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WN7816_CLR(x, v) (BME_AND8(HW_UART_WN7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WN7816_TOG(x, v) (BME_XOR8(HW_UART_WN7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WN7816 bitfields
 */

/*!
 * @name Register UART_WN7816, field GTN[7:0] (RW)
 *
 * Defines a parameter used in the calculation of GT, CGT, and BGT counters. The
 * value represents an integer number between 0 and 255. See Wait time and guard
 * time parameters .
 */
/*@{*/
#define BP_UART_WN7816_GTN   (0U)          /*!< Bit position for UART_WN7816_GTN. */
#define BM_UART_WN7816_GTN   (0xFFU)       /*!< Bit mask for UART_WN7816_GTN. */
#define BS_UART_WN7816_GTN   (8U)          /*!< Bit field size in bits for UART_WN7816_GTN. */

/*! @brief Read current value of the UART_WN7816_GTN field. */
#define BR_UART_WN7816_GTN(x) (HW_UART_WN7816(x).U)

/*! @brief Format value for bitfield UART_WN7816_GTN. */
#define BF_UART_WN7816_GTN(v) ((uint8_t)((uint8_t)(v) << BP_UART_WN7816_GTN) & BM_UART_WN7816_GTN)

/*! @brief Set the GTN field to a new value. */
#define BW_UART_WN7816_GTN(x, v) (HW_UART_WN7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wf7816
{
    uint8_t U;
    struct _hw_uart_wf7816_bitfields
    {
        uint8_t GTFD : 8;              /*!< [7:0] FD Multiplier */
    } B;
} hw_uart_wf7816_t;

/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define HW_UART_WF7816_ADDR(x)   ((x) + 0x1DU)

#define HW_UART_WF7816(x)        (*(__IO hw_uart_wf7816_t *) HW_UART_WF7816_ADDR(x))
#define HW_UART_WF7816_RD(x)     (HW_UART_WF7816(x).U)
#define HW_UART_WF7816_WR(x, v)  (HW_UART_WF7816(x).U = (v))
#define HW_UART_WF7816_SET(x, v) (BME_OR8(HW_UART_WF7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_WF7816_CLR(x, v) (BME_AND8(HW_UART_WF7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WF7816_TOG(x, v) (BME_XOR8(HW_UART_WF7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WF7816 bitfields
 */

/*!
 * @name Register UART_WF7816, field GTFD[7:0] (RW)
 *
 * Used as another multiplier in the calculation of BWT. This value represents a
 * number between 1 and 255. The value of 0 is invalid. This value is not used
 * in baud rate generation. See Wait time and guard time parameters and Baud rate
 * generation .
 */
/*@{*/
#define BP_UART_WF7816_GTFD  (0U)          /*!< Bit position for UART_WF7816_GTFD. */
#define BM_UART_WF7816_GTFD  (0xFFU)       /*!< Bit mask for UART_WF7816_GTFD. */
#define BS_UART_WF7816_GTFD  (8U)          /*!< Bit field size in bits for UART_WF7816_GTFD. */

/*! @brief Read current value of the UART_WF7816_GTFD field. */
#define BR_UART_WF7816_GTFD(x) (HW_UART_WF7816(x).U)

/*! @brief Format value for bitfield UART_WF7816_GTFD. */
#define BF_UART_WF7816_GTFD(v) ((uint8_t)((uint8_t)(v) << BP_UART_WF7816_GTFD) & BM_UART_WF7816_GTFD)

/*! @brief Set the GTFD field to a new value. */
#define BW_UART_WF7816_GTFD(x, v) (HW_UART_WF7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_et7816
{
    uint8_t U;
    struct _hw_uart_et7816_bitfields
    {
        uint8_t RXTHRESHOLD : 4;       /*!< [3:0] Receive NACK Threshold */
        uint8_t TXTHRESHOLD : 4;       /*!< [7:4] Transmit NACK Threshold */
    } B;
} hw_uart_et7816_t;

/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define HW_UART_ET7816_ADDR(x)   ((x) + 0x1EU)

#define HW_UART_ET7816(x)        (*(__IO hw_uart_et7816_t *) HW_UART_ET7816_ADDR(x))
#define HW_UART_ET7816_RD(x)     (HW_UART_ET7816(x).U)
#define HW_UART_ET7816_WR(x, v)  (HW_UART_ET7816(x).U = (v))
#define HW_UART_ET7816_SET(x, v) (BME_OR8(HW_UART_ET7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_ET7816_CLR(x, v) (BME_AND8(HW_UART_ET7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_ET7816_TOG(x, v) (BME_XOR8(HW_UART_ET7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
#define BP_UART_ET7816_RXTHRESHOLD (0U)    /*!< Bit position for UART_ET7816_RXTHRESHOLD. */
#define BM_UART_ET7816_RXTHRESHOLD (0x0FU) /*!< Bit mask for UART_ET7816_RXTHRESHOLD. */
#define BS_UART_ET7816_RXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_RXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define BR_UART_ET7816_RXTHRESHOLD(x) (BME_UBFX8(HW_UART_ET7816_ADDR(x), BP_UART_ET7816_RXTHRESHOLD, BS_UART_ET7816_RXTHRESHOLD))

/*! @brief Format value for bitfield UART_ET7816_RXTHRESHOLD. */
#define BF_UART_ET7816_RXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD) & BM_UART_ET7816_RXTHRESHOLD)

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_RXTHRESHOLD(x, v) (BME_BFI8(HW_UART_ET7816_ADDR(x), ((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD), BP_UART_ET7816_RXTHRESHOLD, 4))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0 - TXT asserts on the first NACK that is received.
 * - 1 - TXT asserts on the second NACK that is received.
 */
/*@{*/
#define BP_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit position for UART_ET7816_TXTHRESHOLD. */
#define BM_UART_ET7816_TXTHRESHOLD (0xF0U) /*!< Bit mask for UART_ET7816_TXTHRESHOLD. */
#define BS_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_TXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define BR_UART_ET7816_TXTHRESHOLD(x) (BME_UBFX8(HW_UART_ET7816_ADDR(x), BP_UART_ET7816_TXTHRESHOLD, BS_UART_ET7816_TXTHRESHOLD))

/*! @brief Format value for bitfield UART_ET7816_TXTHRESHOLD. */
#define BF_UART_ET7816_TXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD) & BM_UART_ET7816_TXTHRESHOLD)

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_TXTHRESHOLD(x, v) (BME_BFI8(HW_UART_ET7816_ADDR(x), ((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD), BP_UART_ET7816_TXTHRESHOLD, 4))
/*@}*/

/*******************************************************************************
 * HW_UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief HW_UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
typedef union _hw_uart_tl7816
{
    uint8_t U;
    struct _hw_uart_tl7816_bitfields
    {
        uint8_t TLEN : 8;              /*!< [7:0] Transmit Length */
    } B;
} hw_uart_tl7816_t;

/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define HW_UART_TL7816_ADDR(x)   ((x) + 0x1FU)

#define HW_UART_TL7816(x)        (*(__IO hw_uart_tl7816_t *) HW_UART_TL7816_ADDR(x))
#define HW_UART_TL7816_RD(x)     (HW_UART_TL7816(x).U)
#define HW_UART_TL7816_WR(x, v)  (HW_UART_TL7816(x).U = (v))
#define HW_UART_TL7816_SET(x, v) (BME_OR8(HW_UART_TL7816_ADDR(x), (uint8_t)(v)))
#define HW_UART_TL7816_CLR(x, v) (BME_AND8(HW_UART_TL7816_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_TL7816_TOG(x, v) (BME_XOR8(HW_UART_TL7816_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_TL7816 bitfields
 */

/*!
 * @name Register UART_TL7816, field TLEN[7:0] (RW)
 *
 * This value plus four indicates the number of characters contained in the
 * block being transmitted. This register is automatically decremented by 1 for each
 * character in the information field portion of the block. Additionally, this
 * register is automatically decremented by 1 for the first character of a CRC in
 * the epilogue field. Therefore, this register must be programmed with the number
 * of bytes in the data packet if an LRC is being transmitted, and the number of
 * bytes + 1 if a CRC is being transmitted. This register is not decremented for
 * characters that are assumed to be part of the Prologue field, that is, the
 * first three characters transmitted in a block, or the LRC or last CRC character
 * in the Epilogue field, that is, the last character transmitted. This field
 * must be programed or adjusted only when C2[TE] is cleared.
 */
/*@{*/
#define BP_UART_TL7816_TLEN  (0U)          /*!< Bit position for UART_TL7816_TLEN. */
#define BM_UART_TL7816_TLEN  (0xFFU)       /*!< Bit mask for UART_TL7816_TLEN. */
#define BS_UART_TL7816_TLEN  (8U)          /*!< Bit field size in bits for UART_TL7816_TLEN. */

/*! @brief Read current value of the UART_TL7816_TLEN field. */
#define BR_UART_TL7816_TLEN(x) (HW_UART_TL7816(x).U)

/*! @brief Format value for bitfield UART_TL7816_TLEN. */
#define BF_UART_TL7816_TLEN(v) ((uint8_t)((uint8_t)(v) << BP_UART_TL7816_TLEN) & BM_UART_TL7816_TLEN)

/*! @brief Set the TLEN field to a new value. */
#define BW_UART_TL7816_TLEN(x, v) (HW_UART_TL7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816A_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
typedef union _hw_uart_ap7816a_t0
{
    uint8_t U;
    struct _hw_uart_ap7816a_t0_bitfields
    {
        uint8_t ADTI_H : 8;            /*!< [7:0] ATR Duration Time Integer High
                                        * (C7816[TTYPE] = 0) */
    } B;
} hw_uart_ap7816a_t0_t;

/*!
 * @name Constants and macros for entire UART_AP7816A_T0 register
 */
/*@{*/
#define HW_UART_AP7816A_T0_ADDR(x) ((x) + 0x3AU)

#define HW_UART_AP7816A_T0(x)    (*(__IO hw_uart_ap7816a_t0_t *) HW_UART_AP7816A_T0_ADDR(x))
#define HW_UART_AP7816A_T0_RD(x) (HW_UART_AP7816A_T0(x).U)
#define HW_UART_AP7816A_T0_WR(x, v) (HW_UART_AP7816A_T0(x).U = (v))
#define HW_UART_AP7816A_T0_SET(x, v) (BME_OR8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_AP7816A_T0_CLR(x, v) (BME_AND8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_AP7816A_T0_TOG(x, v) (BME_XOR8(HW_UART_AP7816A_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_AP7816A_T0 bitfields
 */

/*!
 * @name Register UART_AP7816A_T0, field ADTI_H[7:0] (RW)
 *
 * Used to calculate the value used for the ADT Counter. This register field
 * provides the most significant byte of the 16 bit ATR Duration Time Integer field
 * ADTI formed by {AP7816A_T0[ADTI_H], AP7816B_T0[ADTI_L]}. Programming a value
 * of ADTI = 0 disables the ADT counter. This value is used only when C7816[TTYPE]
 * = 0. See ATR Duration Time Counter.
 */
/*@{*/
#define BP_UART_AP7816A_T0_ADTI_H (0U)     /*!< Bit position for UART_AP7816A_T0_ADTI_H. */
#define BM_UART_AP7816A_T0_ADTI_H (0xFFU)  /*!< Bit mask for UART_AP7816A_T0_ADTI_H. */
#define BS_UART_AP7816A_T0_ADTI_H (8U)     /*!< Bit field size in bits for UART_AP7816A_T0_ADTI_H. */

/*! @brief Read current value of the UART_AP7816A_T0_ADTI_H field. */
#define BR_UART_AP7816A_T0_ADTI_H(x) (HW_UART_AP7816A_T0(x).U)

/*! @brief Format value for bitfield UART_AP7816A_T0_ADTI_H. */
#define BF_UART_AP7816A_T0_ADTI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_AP7816A_T0_ADTI_H) & BM_UART_AP7816A_T0_ADTI_H)

/*! @brief Set the ADTI_H field to a new value. */
#define BW_UART_AP7816A_T0_ADTI_H(x, v) (HW_UART_AP7816A_T0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816B_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
typedef union _hw_uart_ap7816b_t0
{
    uint8_t U;
    struct _hw_uart_ap7816b_t0_bitfields
    {
        uint8_t ADTI_L : 8;            /*!< [7:0] ATR Duration Time Integer Low
                                        * (C7816[TTYPE] = 0) */
    } B;
} hw_uart_ap7816b_t0_t;

/*!
 * @name Constants and macros for entire UART_AP7816B_T0 register
 */
/*@{*/
#define HW_UART_AP7816B_T0_ADDR(x) ((x) + 0x3BU)

#define HW_UART_AP7816B_T0(x)    (*(__IO hw_uart_ap7816b_t0_t *) HW_UART_AP7816B_T0_ADDR(x))
#define HW_UART_AP7816B_T0_RD(x) (HW_UART_AP7816B_T0(x).U)
#define HW_UART_AP7816B_T0_WR(x, v) (HW_UART_AP7816B_T0(x).U = (v))
#define HW_UART_AP7816B_T0_SET(x, v) (BME_OR8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_AP7816B_T0_CLR(x, v) (BME_AND8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_AP7816B_T0_TOG(x, v) (BME_XOR8(HW_UART_AP7816B_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_AP7816B_T0 bitfields
 */

/*!
 * @name Register UART_AP7816B_T0, field ADTI_L[7:0] (RW)
 *
 * Used to calculate the value used for the ADT counter. This register field
 * provides the least significant byte of the 16 bit ATR Duration Time Integer field
 * ADTI formed by {AP7816A_T0[ADTI_H], AP7816B_T0[ADTI_L]}. Programming a value
 * of ADTI = 0 disables the ADT counter. This value is used only when
 * C7816[TTYPE] = 0. See ATR Duration Time Counter.
 */
/*@{*/
#define BP_UART_AP7816B_T0_ADTI_L (0U)     /*!< Bit position for UART_AP7816B_T0_ADTI_L. */
#define BM_UART_AP7816B_T0_ADTI_L (0xFFU)  /*!< Bit mask for UART_AP7816B_T0_ADTI_L. */
#define BS_UART_AP7816B_T0_ADTI_L (8U)     /*!< Bit field size in bits for UART_AP7816B_T0_ADTI_L. */

/*! @brief Read current value of the UART_AP7816B_T0_ADTI_L field. */
#define BR_UART_AP7816B_T0_ADTI_L(x) (HW_UART_AP7816B_T0(x).U)

/*! @brief Format value for bitfield UART_AP7816B_T0_ADTI_L. */
#define BF_UART_AP7816B_T0_ADTI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_AP7816B_T0_ADTI_L) & BM_UART_AP7816B_T0_ADTI_L)

/*! @brief Set the ADTI_L field to a new value. */
#define BW_UART_AP7816B_T0_ADTI_L(x, v) (HW_UART_AP7816B_T0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816A_T0 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816a_t0
{
    uint8_t U;
    struct _hw_uart_wp7816a_t0_bitfields
    {
        uint8_t WI_H : 8;              /*!< [7:0] Wait Time Integer High (C7816[TTYPE] =
                                        * 0) */
    } B;
} hw_uart_wp7816a_t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816A_T0 register
 */
/*@{*/
#define HW_UART_WP7816A_T0_ADDR(x) ((x) + 0x3CU)

#define HW_UART_WP7816A_T0(x)    (*(__IO hw_uart_wp7816a_t0_t *) HW_UART_WP7816A_T0_ADDR(x))
#define HW_UART_WP7816A_T0_RD(x) (HW_UART_WP7816A_T0(x).U)
#define HW_UART_WP7816A_T0_WR(x, v) (HW_UART_WP7816A_T0(x).U = (v))
#define HW_UART_WP7816A_T0_SET(x, v) (BME_OR8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816A_T0_CLR(x, v) (BME_AND8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816A_T0_TOG(x, v) (BME_XOR8(HW_UART_WP7816A_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816A_T0 bitfields
 */

/*!
 * @name Register UART_WP7816A_T0, field WI_H[7:0] (RW)
 *
 * Used to calculate the value used for the WT counter. This register field
 * provides the most significant byte of the 16 bit Wait Time Integer field WI formed
 * by {WP7816A_T0[WI_H], WP7816B_T0[WI_L]}. The value of WI = 0 is invalid and
 * must not be programmed. This value is used only when C7816[TTYPE] = 0. See Wait
 * time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816A_T0_WI_H (0U)       /*!< Bit position for UART_WP7816A_T0_WI_H. */
#define BM_UART_WP7816A_T0_WI_H (0xFFU)    /*!< Bit mask for UART_WP7816A_T0_WI_H. */
#define BS_UART_WP7816A_T0_WI_H (8U)       /*!< Bit field size in bits for UART_WP7816A_T0_WI_H. */

/*! @brief Read current value of the UART_WP7816A_T0_WI_H field. */
#define BR_UART_WP7816A_T0_WI_H(x) (HW_UART_WP7816A_T0(x).U)

/*! @brief Format value for bitfield UART_WP7816A_T0_WI_H. */
#define BF_UART_WP7816A_T0_WI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816A_T0_WI_H) & BM_UART_WP7816A_T0_WI_H)

/*! @brief Set the WI_H field to a new value. */
#define BW_UART_WP7816A_T0_WI_H(x, v) (HW_UART_WP7816A_T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816B_T0 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816b_t0
{
    uint8_t U;
    struct _hw_uart_wp7816b_t0_bitfields
    {
        uint8_t WI_L : 8;              /*!< [7:0] Wait Time Integer Low (C7816[TTYPE] = 0)
                                        * */
    } B;
} hw_uart_wp7816b_t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816B_T0 register
 */
/*@{*/
#define HW_UART_WP7816B_T0_ADDR(x) ((x) + 0x3DU)

#define HW_UART_WP7816B_T0(x)    (*(__IO hw_uart_wp7816b_t0_t *) HW_UART_WP7816B_T0_ADDR(x))
#define HW_UART_WP7816B_T0_RD(x) (HW_UART_WP7816B_T0(x).U)
#define HW_UART_WP7816B_T0_WR(x, v) (HW_UART_WP7816B_T0(x).U = (v))
#define HW_UART_WP7816B_T0_SET(x, v) (BME_OR8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816B_T0_CLR(x, v) (BME_AND8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816B_T0_TOG(x, v) (BME_XOR8(HW_UART_WP7816B_T0_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816B_T0 bitfields
 */

/*!
 * @name Register UART_WP7816B_T0, field WI_L[7:0] (RW)
 *
 * Used to calculate the value used for the WT counter. This register field
 * provides the least significant byte of the 16 bit Wait Time Integer field WI
 * formed by {WP7816A_T0[WI_H], WP7816B_T0[WI_L]} . The value of WI = 0 is invalid and
 * must not be programmed. This value is used only when C7816[TTYPE] = 0. See
 * Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816B_T0_WI_L (0U)       /*!< Bit position for UART_WP7816B_T0_WI_L. */
#define BM_UART_WP7816B_T0_WI_L (0xFFU)    /*!< Bit mask for UART_WP7816B_T0_WI_L. */
#define BS_UART_WP7816B_T0_WI_L (8U)       /*!< Bit field size in bits for UART_WP7816B_T0_WI_L. */

/*! @brief Read current value of the UART_WP7816B_T0_WI_L field. */
#define BR_UART_WP7816B_T0_WI_L(x) (HW_UART_WP7816B_T0(x).U)

/*! @brief Format value for bitfield UART_WP7816B_T0_WI_L. */
#define BF_UART_WP7816B_T0_WI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816B_T0_WI_L) & BM_UART_WP7816B_T0_WI_L)

/*! @brief Set the WI_L field to a new value. */
#define BW_UART_WP7816B_T0_WI_L(x, v) (HW_UART_WP7816B_T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816A_T1 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816a_t1
{
    uint8_t U;
    struct _hw_uart_wp7816a_t1_bitfields
    {
        uint8_t BWI_H : 8;             /*!< [7:0] Block Wait Time Integer High
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816a_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816A_T1 register
 */
/*@{*/
#define HW_UART_WP7816A_T1_ADDR(x) ((x) + 0x3CU)

#define HW_UART_WP7816A_T1(x)    (*(__IO hw_uart_wp7816a_t1_t *) HW_UART_WP7816A_T1_ADDR(x))
#define HW_UART_WP7816A_T1_RD(x) (HW_UART_WP7816A_T1(x).U)
#define HW_UART_WP7816A_T1_WR(x, v) (HW_UART_WP7816A_T1(x).U = (v))
#define HW_UART_WP7816A_T1_SET(x, v) (BME_OR8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816A_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816A_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816A_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816A_T1 bitfields
 */

/*!
 * @name Register UART_WP7816A_T1, field BWI_H[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. This register field
 * provides the most significant byte of the 16 bit Block Wait Time Integer field
 * BWI formed by {WP7816A_T1[BWI_H], WP7816B_T1[BWI_L]}. The value of BWI = 0 is
 * invalid and should not be programmed. This value is used only when C7816[TTYPE]
 * = 1. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816A_T1_BWI_H (0U)      /*!< Bit position for UART_WP7816A_T1_BWI_H. */
#define BM_UART_WP7816A_T1_BWI_H (0xFFU)   /*!< Bit mask for UART_WP7816A_T1_BWI_H. */
#define BS_UART_WP7816A_T1_BWI_H (8U)      /*!< Bit field size in bits for UART_WP7816A_T1_BWI_H. */

/*! @brief Read current value of the UART_WP7816A_T1_BWI_H field. */
#define BR_UART_WP7816A_T1_BWI_H(x) (HW_UART_WP7816A_T1(x).U)

/*! @brief Format value for bitfield UART_WP7816A_T1_BWI_H. */
#define BF_UART_WP7816A_T1_BWI_H(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816A_T1_BWI_H) & BM_UART_WP7816A_T1_BWI_H)

/*! @brief Set the BWI_H field to a new value. */
#define BW_UART_WP7816A_T1_BWI_H(x, v) (HW_UART_WP7816A_T1_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816B_T1 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816b_t1
{
    uint8_t U;
    struct _hw_uart_wp7816b_t1_bitfields
    {
        uint8_t BWI_L : 8;             /*!< [7:0] Block Wait Time Integer Low
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wp7816b_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816B_T1 register
 */
/*@{*/
#define HW_UART_WP7816B_T1_ADDR(x) ((x) + 0x3DU)

#define HW_UART_WP7816B_T1(x)    (*(__IO hw_uart_wp7816b_t1_t *) HW_UART_WP7816B_T1_ADDR(x))
#define HW_UART_WP7816B_T1_RD(x) (HW_UART_WP7816B_T1(x).U)
#define HW_UART_WP7816B_T1_WR(x, v) (HW_UART_WP7816B_T1(x).U = (v))
#define HW_UART_WP7816B_T1_SET(x, v) (BME_OR8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816B_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816B_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816B_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816B_T1 bitfields
 */

/*!
 * @name Register UART_WP7816B_T1, field BWI_L[7:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. This register field
 * provides the least significant byte of the 16 bit Block Wait Time Integer field
 * BWI formed by {WP7816A_T1[BWI_H], WP7816B_T1[BWI_L]}. The value of BWI = 0 is
 * invalid and should not be programmed. This value is used only when C7816[TTYPE]
 * = 1. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816B_T1_BWI_L (0U)      /*!< Bit position for UART_WP7816B_T1_BWI_L. */
#define BM_UART_WP7816B_T1_BWI_L (0xFFU)   /*!< Bit mask for UART_WP7816B_T1_BWI_L. */
#define BS_UART_WP7816B_T1_BWI_L (8U)      /*!< Bit field size in bits for UART_WP7816B_T1_BWI_L. */

/*! @brief Read current value of the UART_WP7816B_T1_BWI_L field. */
#define BR_UART_WP7816B_T1_BWI_L(x) (HW_UART_WP7816B_T1(x).U)

/*! @brief Format value for bitfield UART_WP7816B_T1_BWI_L. */
#define BF_UART_WP7816B_T1_BWI_L(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816B_T1_BWI_L) & BM_UART_WP7816B_T1_BWI_L)

/*! @brief Set the BWI_L field to a new value. */
#define BW_UART_WP7816B_T1_BWI_L(x, v) (HW_UART_WP7816B_T1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register (RW)
 *
 * Reset value: 0x06U
 *
 * The WGP7816_T1 register contains constants used in the generation of various
 * wait and guard timer counters. This register may be read at any time. This
 * register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wgp7816_t1
{
    uint8_t U;
    struct _hw_uart_wgp7816_t1_bitfields
    {
        uint8_t BGI : 4;               /*!< [3:0] Block Guard Time Integer (C7816[TTYPE] =
                                        * 1) */
        uint8_t CWI1 : 4;              /*!< [7:4] Character Wait Time Integer 1
                                        * (C7816[TTYPE] = 1) */
    } B;
} hw_uart_wgp7816_t1_t;

/*!
 * @name Constants and macros for entire UART_WGP7816_T1 register
 */
/*@{*/
#define HW_UART_WGP7816_T1_ADDR(x) ((x) + 0x3EU)

#define HW_UART_WGP7816_T1(x)    (*(__IO hw_uart_wgp7816_t1_t *) HW_UART_WGP7816_T1_ADDR(x))
#define HW_UART_WGP7816_T1_RD(x) (HW_UART_WGP7816_T1(x).U)
#define HW_UART_WGP7816_T1_WR(x, v) (HW_UART_WGP7816_T1(x).U = (v))
#define HW_UART_WGP7816_T1_SET(x, v) (BME_OR8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WGP7816_T1_CLR(x, v) (BME_AND8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WGP7816_T1_TOG(x, v) (BME_XOR8(HW_UART_WGP7816_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WGP7816_T1 bitfields
 */

/*!
 * @name Register UART_WGP7816_T1, field BGI[3:0] (RW)
 *
 * Used to calculate the value used for the BGT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WGP7816_T1_BGI (0U)        /*!< Bit position for UART_WGP7816_T1_BGI. */
#define BM_UART_WGP7816_T1_BGI (0x0FU)     /*!< Bit mask for UART_WGP7816_T1_BGI. */
#define BS_UART_WGP7816_T1_BGI (4U)        /*!< Bit field size in bits for UART_WGP7816_T1_BGI. */

/*! @brief Read current value of the UART_WGP7816_T1_BGI field. */
#define BR_UART_WGP7816_T1_BGI(x) (BME_UBFX8(HW_UART_WGP7816_T1_ADDR(x), BP_UART_WGP7816_T1_BGI, BS_UART_WGP7816_T1_BGI))

/*! @brief Format value for bitfield UART_WGP7816_T1_BGI. */
#define BF_UART_WGP7816_T1_BGI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WGP7816_T1_BGI) & BM_UART_WGP7816_T1_BGI)

/*! @brief Set the BGI field to a new value. */
#define BW_UART_WGP7816_T1_BGI(x, v) (BME_BFI8(HW_UART_WGP7816_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WGP7816_T1_BGI), BP_UART_WGP7816_T1_BGI, 4))
/*@}*/

/*!
 * @name Register UART_WGP7816_T1, field CWI1[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WGP7816_T1_CWI1 (4U)       /*!< Bit position for UART_WGP7816_T1_CWI1. */
#define BM_UART_WGP7816_T1_CWI1 (0xF0U)    /*!< Bit mask for UART_WGP7816_T1_CWI1. */
#define BS_UART_WGP7816_T1_CWI1 (4U)       /*!< Bit field size in bits for UART_WGP7816_T1_CWI1. */

/*! @brief Read current value of the UART_WGP7816_T1_CWI1 field. */
#define BR_UART_WGP7816_T1_CWI1(x) (BME_UBFX8(HW_UART_WGP7816_T1_ADDR(x), BP_UART_WGP7816_T1_CWI1, BS_UART_WGP7816_T1_CWI1))

/*! @brief Format value for bitfield UART_WGP7816_T1_CWI1. */
#define BF_UART_WGP7816_T1_CWI1(v) ((uint8_t)((uint8_t)(v) << BP_UART_WGP7816_T1_CWI1) & BM_UART_WGP7816_T1_CWI1)

/*! @brief Set the CWI1 field to a new value. */
#define BW_UART_WGP7816_T1_CWI1(x, v) (BME_BFI8(HW_UART_WGP7816_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WGP7816_T1_CWI1), BP_UART_WGP7816_T1_CWI1, 4))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816C_T1 - UART 7816 Wait Parameter Register C (RW)
 *
 * Reset value: 0x0BU
 *
 * The WP7816C_T1 register contains constants used in the generation of various
 * wait timer counters. This register may be read at any time. This register must
 * be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816c_t1
{
    uint8_t U;
    struct _hw_uart_wp7816c_t1_bitfields
    {
        uint8_t CWI2 : 5;              /*!< [4:0] Character Wait Time Integer 2
                                        * (C7816[TTYPE] = 1) */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_wp7816c_t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816C_T1 register
 */
/*@{*/
#define HW_UART_WP7816C_T1_ADDR(x) ((x) + 0x3FU)

#define HW_UART_WP7816C_T1(x)    (*(__IO hw_uart_wp7816c_t1_t *) HW_UART_WP7816C_T1_ADDR(x))
#define HW_UART_WP7816C_T1_RD(x) (HW_UART_WP7816C_T1(x).U)
#define HW_UART_WP7816C_T1_WR(x, v) (HW_UART_WP7816C_T1(x).U = (v))
#define HW_UART_WP7816C_T1_SET(x, v) (BME_OR8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(v)))
#define HW_UART_WP7816C_T1_CLR(x, v) (BME_AND8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(~(v))))
#define HW_UART_WP7816C_T1_TOG(x, v) (BME_XOR8(HW_UART_WP7816C_T1_ADDR(x), (uint8_t)(v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816C_T1 bitfields
 */

/*!
 * @name Register UART_WP7816C_T1, field CWI2[4:0] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 31. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WP7816C_T1_CWI2 (0U)       /*!< Bit position for UART_WP7816C_T1_CWI2. */
#define BM_UART_WP7816C_T1_CWI2 (0x1FU)    /*!< Bit mask for UART_WP7816C_T1_CWI2. */
#define BS_UART_WP7816C_T1_CWI2 (5U)       /*!< Bit field size in bits for UART_WP7816C_T1_CWI2. */

/*! @brief Read current value of the UART_WP7816C_T1_CWI2 field. */
#define BR_UART_WP7816C_T1_CWI2(x) (BME_UBFX8(HW_UART_WP7816C_T1_ADDR(x), BP_UART_WP7816C_T1_CWI2, BS_UART_WP7816C_T1_CWI2))

/*! @brief Format value for bitfield UART_WP7816C_T1_CWI2. */
#define BF_UART_WP7816C_T1_CWI2(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816C_T1_CWI2) & BM_UART_WP7816C_T1_CWI2)

/*! @brief Set the CWI2 field to a new value. */
#define BW_UART_WP7816C_T1_CWI2(x, v) (BME_BFI8(HW_UART_WP7816C_T1_ADDR(x), ((uint8_t)(v) << BP_UART_WP7816C_T1_CWI2), BP_UART_WP7816C_T1_CWI2, 5))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_uart_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART module registers.
 */
#pragma pack(1)
typedef struct _hw_uart
{
    __IO hw_uart_bdh_t BDH;                /*!< [0x0] UART Baud Rate Registers: High */
    __IO hw_uart_bdl_t BDL;                /*!< [0x1] UART Baud Rate Registers: Low */
    __IO hw_uart_c1_t C1;                  /*!< [0x2] UART Control Register 1 */
    __IO hw_uart_c2_t C2;                  /*!< [0x3] UART Control Register 2 */
    __I hw_uart_s1_t S1;                   /*!< [0x4] UART Status Register 1 */
    __IO hw_uart_s2_t S2;                  /*!< [0x5] UART Status Register 2 */
    __IO hw_uart_c3_t C3;                  /*!< [0x6] UART Control Register 3 */
    __IO hw_uart_d_t D;                    /*!< [0x7] UART Data Register */
    __IO hw_uart_ma1_t MA1;                /*!< [0x8] UART Match Address Registers 1 */
    __IO hw_uart_ma2_t MA2;                /*!< [0x9] UART Match Address Registers 2 */
    __IO hw_uart_c4_t C4;                  /*!< [0xA] UART Control Register 4 */
    __IO hw_uart_c5_t C5;                  /*!< [0xB] UART Control Register 5 */
    uint8_t _reserved0[12];
    __IO hw_uart_c7816_t C7816;            /*!< [0x18] UART 7816 Control Register */
    __IO hw_uart_ie7816_t IE7816;          /*!< [0x19] UART 7816 Interrupt Enable Register */
    __IO hw_uart_is7816_t IS7816;          /*!< [0x1A] UART 7816 Interrupt Status Register */
    __IO hw_uart_wp7816_t WP7816;          /*!< [0x1B] UART 7816 Wait Parameter Register */
    __IO hw_uart_wn7816_t WN7816;          /*!< [0x1C] UART 7816 Wait N Register */
    __IO hw_uart_wf7816_t WF7816;          /*!< [0x1D] UART 7816 Wait FD Register */
    __IO hw_uart_et7816_t ET7816;          /*!< [0x1E] UART 7816 Error Threshold Register */
    __IO hw_uart_tl7816_t TL7816;          /*!< [0x1F] UART 7816 Transmit Length Register */
    uint8_t _reserved1[26];
    __IO hw_uart_ap7816a_t0_t AP7816A_T0;  /*!< [0x3A] UART 7816 ATR Duration Timer Register A */
    __IO hw_uart_ap7816b_t0_t AP7816B_T0;  /*!< [0x3B] UART 7816 ATR Duration Timer Register B */
    union {
        struct {
            __IO hw_uart_wp7816a_t0_t WP7816A_T0; /*!< [0x3C] UART 7816 Wait Parameter Register A */
            __IO hw_uart_wp7816b_t0_t WP7816B_T0; /*!< [0x3D] UART 7816 Wait Parameter Register B */
        } TYPE0;
        struct {
            __IO hw_uart_wp7816a_t1_t WP7816A_T1; /*!< [0x3C] UART 7816 Wait Parameter Register A */
            __IO hw_uart_wp7816b_t1_t WP7816B_T1; /*!< [0x3D] UART 7816 Wait Parameter Register B */
        } TYPE1;
    };
    __IO hw_uart_wgp7816_t1_t WGP7816_T1;  /*!< [0x3E] UART 7816 Wait and Guard Parameter Register */
    __IO hw_uart_wp7816c_t1_t WP7816C_T1;  /*!< [0x3F] UART 7816 Wait Parameter Register C */
} hw_uart_t;
#pragma pack()

/*! @brief Macro to access all UART registers. */
/*! @param x UART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART(UART2_BASE)</code>. */
#define HW_UART(x)     (*(hw_uart_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

#endif /* __HW_UART_REGISTERS_H__ */
/* EOF */
